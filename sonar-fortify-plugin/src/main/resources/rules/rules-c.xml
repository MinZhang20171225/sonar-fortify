<rules>
  <!-- see names and descriptions in org/sonar/l10n/ -->
  <rule>
    <key>api_abuse_dangerous_function</key>
    <internalKey>API Abuse/Dangerous Function</internalKey>
    <name>Dangerous Function</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Functions that cannot be used safely should never be used.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Certain functions behave in dangerous ways regardless of how they are used. Functions in this category were often implemented without taking security concerns into account.<br><br>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP2060.4 CAT II, APP3590.2 CAT I</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP2060.4 CAT II, APP3590.2 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP2060.4 CAT II, APP3590.2 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP2060.4 CAT II, APP3590.2 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP2060.4 CAT II, APP3590.2 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 242</em> <br></p>
																									   <p>[7] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[9] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 676</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_dangerous_function_strcpy_</key>
    <internalKey>API Abuse/Dangerous Function/strcpy()</internalKey>
    <name>Dangerous Function: strcpy()</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Functions that cannot be used safely should never be used.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Certain functions behave in dangerous ways regardless of how they are used. Functions in this category were often implemented without taking security concerns into account.<br><br>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP2060.4 CAT II, APP3590.2 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP2060.4 CAT II, APP3590.2 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP2060.4 CAT II, APP3590.2 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP2060.4 CAT II, APP3590.2 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP2060.4 CAT II, APP3590.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Buffer Overflow</em> <br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 676</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 676</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_directory_restriction</key>
    <internalKey>API Abuse/Directory Restriction</internalKey>
    <name>Directory Restriction</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Improper use of the <code>chroot()</code> system call could allow attackers to escape a chroot jail.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>chroot()</code> system call allows a process to change its perception of the root directory of the file system. After properly invoking <code>chroot()</code>, a process cannot access any files outside the directory tree defined by the new root directory. Such an environment is called a chroot jail and is commonly used to prevent the possibility that a processes could be subverted and used to access unauthorized files. For instance, many FTP servers run in chroot jails to prevent an attacker who discovers a new vulnerability in the server from being able to download the password file or other sensitive files on the system.<br><br>Improper use of <code>chroot()</code> may allow attackers to escape from the chroot jail. The <code>chroot()</code> function call does not change the process's current working directory, so relative paths may still refer to file system resources outside of the chroot jail after <code>chroot()</code> has been called.<br><br><b>Example 1:</b> Consider the following source code from a (hypothetical) FTP server:<br><br><pre><br>chroot("/var/ftproot");<br>...<br>fgets(filename, sizeof(filename), network);<br>localfile = fopen(filename, "r");<br>while ((len = fread(buf, 1, sizeof(buf), localfile)) != EOF) {<br>  fwrite(buf, 1, sizeof(buf), network);<br>}<br>fclose(localfile);<br></pre><br><br>This code is responsible for reading a filename from the network, opening the corresponding file on the local machine, and sending the contents over the network. This code could be used to implement the FTP <code>GET</code> command. The FTP server calls <code>chroot()</code> in its initialization routines in an attempt to prevent access to files outside of <code>/var/ftproot</code>. But because the server fails to change the current working directory by calling <code>chdir("/")</code>, an attacker could request the file <code>"../../../../../etc/passwd</code>" and obtain a copy of the system password file.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[2] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 243</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[4] A. Chuvakin <em>Using Chroot Securely</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_heap_inspection</key>
    <internalKey>API Abuse/Heap Inspection</internalKey>
    <name>Heap Inspection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Do not use <code>realloc()</code> to resize buffers that store sensitive information.  The function might leave a copy of the sensitive information stranded in memory where it cannot be overwritten.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Heap inspection vulnerabilities occur when sensitive data, such as a password or an encryption key, can be exposed to an attacker because they are not removed from memory.<br><br>The <code>realloc()</code> function is commonly used to increase the size of a block of allocated memory. This operation often requires copying the contents of the old memory block into a new and larger block. This operation leaves the contents of the original block intact but inaccessible to the program, preventing the program from being able to scrub sensitive data from memory. If an attacker can later examine the contents of a memory dump, the sensitive data could be exposed.<br><br><br><br><b>Example:</b> The following code calls <code>realloc()</code> on a buffer containing sensitive data:<br><br><pre><br>cleartext_buffer = get_secret();<br>...<br>cleartext_buffer = realloc(cleartext_buffer, 1024);<br>...<br>scrub_memory(cleartext_buffer, 1024);<br></pre><br><br>There is an attempt to scrub the sensitive data from memory, but <code>realloc()</code> is used, so a copy of the data can still be exposed in the memory originally allocated for <code>cleartext_buffer</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 244</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[12] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-4 Information in Shared Resources (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_heap_inspection_swappable_memory</key>
    <internalKey>API Abuse/Heap Inspection/Swappable Memory</internalKey>
    <name>Heap Inspection: Swappable Memory</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Do not use <code>VirtualLock</code> to lock pages that contain sensitive data. The function is not always implemented.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Heap inspection vulnerabilities occur when sensitive data, such as a password or an encryption key, can be exposed to an attacker because they are not removed from memory.<br><br>The <code>VirtualLock</code> function is intended to lock pages in memory to prevent them from being paged to disk. However, on Windows 95/98/ME the function is implemented as stub only and has no effect.<br><br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 591</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[12] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-4 Information in Shared Resources (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_missing_check_against_null</key>
    <internalKey>API Abuse/Missing Check against Null</internalKey>
    <name>Missing Check against Null</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program can dereference a null pointer because it does not check the return value of a function that might return null.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.<br><br>Two dubious assumptions that are easy to spot in code are "this function call can never fail" and "it doesn't matter if this function call fails". When a programmer ignores the return value from a function, they implicitly state that they are operating under one of these assumptions.<br><br><b>Example 1:</b>  The following code does not check to see if memory allocation succeeded before attempting to use the pointer returned by <code>malloc()</code>.<br><br><pre><br>    buf = (char*) malloc(req_size);<br>    strncpy(buf, xfer, req_size);<br></pre><br><br>The traditional defense of this coding error is:<br><br>"If my program runs out of memory, it will fail. It doesn't matter whether I handle the error or simply allow the program to die with a segmentation fault when it tries to dereference the null pointer."<br><br>This argument ignores three important considerations:<br><br>- Depending upon the type and size of the application, it may be possible to free memory that is being used elsewhere so that execution can continue.<br><br>- It is impossible for the program to perform a graceful exit if required. If the program is performing an atomic operation, it can leave the system in an inconsistent state.<br><br>- The programmer has lost the opportunity to record diagnostic information. Did the call to <code>malloc()</code> fail because <code>req_size</code> was too large or because there were too many requests being handled at the same time? Or was it caused by a memory leak that has built up over time? Without handling the error, there is no way to know.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II, APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II, APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II, APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II, APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II, APP6080 CAT II</em> <br></p>
																									   <p>[7] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 253, CWE ID 690</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_authentication_gethostby</key>
    <internalKey>API Abuse/Often Misused/Authentication(gethostby)</internalKey>
    <name>Often Misused: Authentication(gethostby)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Attackers can spoof DNS entries. Do not rely on DNS names for security.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Many DNS servers are susceptible to spoofing attacks, so you should assume that your software will someday run in an environment with a compromised DNS server. If attackers are allowed to make DNS updates (sometimes called DNS cache poisoning), they can route your network traffic through their machines or make it appear as if their IP addresses are part of your domain. Do not base the security of your system on DNS names.<br><br><b>Example 1:</b> The following code uses a DNS lookup to determine whether or not an inbound request is from a trusted host. If an attacker can poison the DNS cache, they can gain trusted status.<br><br><pre><br> struct hostent *hp;<br> struct in_addr myaddr;<br> char* tHost = "trustme.trusty.com";<br> myaddr.s_addr=inet_addr(ip_addr_string);<br><br> hp = gethostbyaddr((char *) &amp;myaddr,<br>      sizeof(struct in_addr), AF_INET);<br> if (hp &amp;&amp; !strncmp(hp-&gt;h_name, tHost, sizeof(tHost))) {<br> trusted = true;<br> } else {<br> trusted = false;<br> }<br></pre><br><br>IP addresses are more reliable than DNS names, but they can also be spoofed. Attackers can easily forge the source IP address of the packets they send, but response packets will return to the forged IP address. To see the response packets, the attacker has to sniff the traffic between the victim machine and the forged IP address. In order to accomplish the required sniffing, attackers typically attempt to locate themselves on the same subnet as the victim machine. Attackers may be able to circumvent this requirement by using source routing, but source routing is disabled across much of the Internet today. In summary, IP address verification can be a useful part of an authentication scheme, but it should not be the single factor required for authentication.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3460 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3460 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3460 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3460 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3460 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 247, CWE ID 292, CWE ID 558, CWE ID 807</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 807</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 807</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-23 Session Authenticity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_authentication_getlogin</key>
    <internalKey>API Abuse/Often Misused/Authentication(getlogin)</internalKey>
    <name>Often Misused: Authentication(getlogin)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The <code>getlogin()</code> function is easy to spoof. Do not rely on the name it returns.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>getlogin()</code> function is supposed to return a string containing the name of the user currently logged in at the terminal, but an attacker can cause <code>getlogin()</code> to return the name of any user logged in to the machine. Do not rely on the name returned by <code>getlogin()</code> when making security decisions.<br><br><b>Example 1:</b> The following code relies on <code>getlogin()</code> to determine whether or not a user is trusted. It is easily subverted.<br><br><pre><br> pwd = getpwnam(getlogin());<br> if (isTrustedGroup(pwd-&gt;pw_gid)) {<br> allow();<br> } else {<br> deny();<br> }<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3460 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3460 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3460 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3460 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3460 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 247, CWE ID 292, CWE ID 558, CWE ID 807</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 807</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 807</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-23 Session Authenticity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_exception_handling__alloca</key>
    <internalKey>API Abuse/Often Misused/Exception Handling(_alloca)</internalKey>
    <name>Often Misused: Exception Handling(_alloca)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The <code>_alloca()</code> function can throw a stack overflow exception, potentially causing the program to crash.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>_alloca()</code> function allocates memory on the stack. If an allocation request is too large for the available stack space, <code>_alloca()</code> throws an exception. If the exception is not caught, the program will crash, potentially enabling a denial of service attack.<br><br><code>_alloca()</code> has been deprecated as of Microsoft Visual Studio 2005(R). It has been replaced with the more secure <code>_alloca_s()</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A7 Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 248</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.2, Requirement 6.5.6</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[13] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_exception_handling_criticalsection</key>
    <internalKey>API Abuse/Often Misused/Exception Handling(criticalsection)</internalKey>
    <name>Often Misused: Exception Handling(criticalsection)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  <code>EnterCriticalSection()</code> can raise an exception, potentially causing the program to crash.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Under operating systems prior to Windows 2000, the <code>EnterCriticalSection()</code> function can raise an exception in low memory situations. If the exception is not caught, the program will crash, potentially enabling a denial of service attack.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A7 Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 248</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.2, Requirement 6.5.6</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[13] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_file_system_getwd</key>
    <internalKey>API Abuse/Often Misused/File System(getwd)</internalKey>
    <name>Often Misused: File System(getwd)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Calling <code>getwd()</code> with a buffer that is too small can result in a buffer overflow.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The function <code>getwd()</code> retrieves the absolute path of the current working directory. The function is a wrapper that calls <code>getcwd(buf, PATH_MAX)</code>, thereby assuming that <code>buf</code> can hold at least <code>PATH_MAX</code> bytes. If <code>buf</code> is not large enough, an attacker can overflow the buffer by creating a directory with a very long name.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 249, CWE ID 560</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_file_system_readlink</key>
    <internalKey>API Abuse/Often Misused/File System(readlink)</internalKey>
    <name>Often Misused: File System(readlink)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The function <code>readlink()</code> does not null terminate its output.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The function <code>readlink()</code> takes three arguments:<code> linkname, buffer,</code> and <code>buf_sz</code>. The function looks up the name of the file pointed to by the symbolic link <code>linkname</code> and stores the resolved name to the second argument, <code>buffer</code>. The function stores at most <code>buf_sz</code> characters to <code>buffer</code>. This function is unusual in the C library because it makes no effort to null terminate <code>buffer</code>. Instead, it returns the number of characters it has written.<br><br>A typical misuse of <code>readlink()</code> looks like this:<br><br><pre><br> char buf[256];<br> len = readlink(lname, buf, sizeof(buf));<br> buf[len] = '\0';<br></pre><br><br>If <code>len</code> is equal to <code>sizeof(buf)</code>, the null terminator will be written one byte past the end of <code>buf</code>.<br><br>A simple (but incorrect) solution to this problem is to try to make <code>buf</code> large enough that it can always hold the result:<br><br><pre><br> char buf[PATH_MAX+1];<br> len = readlink(lname, buf, sizeof(buf));<br> buf[len] = '\0';<br></pre><br><br>But this "fix" incorrectly assumes that <code>PATH_MAX</code> represents the longest possible path for a file in the filesystem. (<code>PATH_MAX</code> only bounds the longest possible relative path that can be passed to the kernel in a single call.) On most Unix and Linux systems, there is no easily-determined maximum length for a file path, and so the off-by-one buffer overflow risk is still present.<br><br>Buffer overflows aside, whenever a single call to <code>readlink()</code> returns the same value that has been passed to its third argument, it is impossible to know whether the name is precisely that many bytes long, or whether <code>readlink()</code> has truncated the name to avoid overrunning the buffer.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 249, CWE ID 560</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12]  <em>The GNU C Library Reference Manual</em> The GNU Software Foundation<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_file_system_realpath</key>
    <internalKey>API Abuse/Often Misused/File System(realpath)</internalKey>
    <name>Often Misused: File System(realpath)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The buffer passed to <code>realpath()</code> should hold at least <code>PATH_MAX</code> bytes.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The C standard library function <code>realpath()</code> takes two arguments. The first argument specifies a filename to be converted to canonical form. The second argument specifies an output buffer. Regardless of the length of the canonicalized file name, <code>realpath()</code> will not write more than <code>PATH_MAX</code> bytes to the output buffer.<br><br>Some programmers incorrectly assume that, by allocating a buffer of size <code>PATH_MAX</code>, there will always be enough room in the buffer to hold any file name that might be found on the system. However, <code>PATH_MAX</code> only bounds the longest possible relative path that can be passed to the kernel in a single call. On most Unix and Linux systems, there is no easily-determined maximum length for a path.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 249, CWE ID 560</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12]  <em>The GNU C Library Reference Manual</em> The GNU Software Foundation<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_file_system_umask</key>
    <internalKey>API Abuse/Often Misused/File System(umask)</internalKey>
    <name>Often Misused: File System(umask)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The mask specified by the argument <code>umask()</code> is often confused with the argument to <code>chmod()</code>.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>umask()</code> man page begins with the false statement:<br><br>"umask sets the umask to mask &amp; 0777"<br><br>Although this behavior would better align with the usage of <code>chmod()</code>, where the user provided argument specifies the bits to enable on the specified file, the behavior of <code>umask()</code> is in fact opposite: <code>umask()</code> sets the umask to <code>~mask &amp; 0777</code>.<br><br>The <code>umask()</code> man page goes on to describe the correct usage of <code>umask()</code>:<br><br>"The umask is used by <code>open()</code> to set initial file permissions on a newly-created file. Specifically, permissions in the umask are turned off from the mode argument to <code>open(2)</code> (so, for example, the common umask default value of 022 results in new files being created with permissions 0666 &amp; ~022 = 0644 = rw-r--r-- in the usual case where the mode is specified as 0666)."
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 249, CWE ID 560</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_file_system_windows</key>
    <internalKey>API Abuse/Often Misused/File System(windows)</internalKey>
    <name>Often Misused: File System(windows)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Passing an inadequately-sized output buffer to a path manipulation function can result in a buffer overflow. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Windows provides a large number of utility functions that manipulate buffers containing filenames. In most cases, the result is returned in a buffer that is passed in as input. (Usually the filename is modified in place.) Most functions require the buffer to be at least <code>MAX_PATH</code> bytes in length, but you should check the documentation for each function individually. If the buffer is not large enough to store the result of the manipulation, a buffer overflow can occur.<br><br><b>Example:</b><br><br><pre><br>char *createOutputDirectory(char *name) {<br>	char outputDirectoryName[128];<br>	if (getCurrentDirectory(128, outputDirectoryName) == 0) {<br>		return null;<br>	}<br>	if (!PathAppend(outputDirectoryName, "output")) {<br>		return null;<br>	}<br>	if (!PathAppend(outputDirectoryName, name)) {<br>		return null;<br>	}<br>	if (SHCreateDirectoryEx(NULL, outputDirectoryName, NULL)<br>        != ERROR_SUCCESS) {<br>		return null;<br>	}<br>	return StrDup(outputDirectoryName);<br>}<br></pre><br><br>In this example the function creates a directory named "<code>output\&lt;name&gt;</code>" in the current directory and returns a heap-allocated copy of its name. For most values of the current directory and the name parameter, this function will work properly. However, if the <code>name</code> parameter is particularly long, then the second call to <code>PathAppend()</code> could overflow the <code>outputDirectoryName</code> buffer, which is smaller than <code>MAX_PATH</code> bytes.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 249, CWE ID 560</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_privilege_management</key>
    <internalKey>API Abuse/Often Misused/Privilege Management</internalKey>
    <name>Often Misused: Privilege Management</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Failure to adhere to the principle of least privilege amplifies the risk posed by other vulnerabilities.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Programs that run with <code>root</code> privileges have caused innumerable Unix security disasters. It is imperative that you carefully review privileged programs for all kinds of security problems, but it is equally important that privileged programs drop back to an unprivileged state as quickly as possible in order to limit the amount of damage that an overlooked vulnerability might be able to cause.<br>    <br><br>    Privilege management functions can behave in some less-than-obvious ways, and they have different quirks on different platforms. These inconsistencies are particularly pronounced if you are transitioning from one non-<code>root</code> user to another.<br><br>    Signal handlers and spawned processes run at the privilege of the owning process, so if a process is running as <code>root</code> when a signal fires or a sub-process is executed, the signal handler or sub-process will operate with root privileges. An attacker may be able to leverage these elevated privileges to do further damage.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-6 Least Privilege (P1)</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3500 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3500 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3500 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3500 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3500 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 250</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[10] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 250</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 250</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 7.1.1</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 7.1.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 7.1.2</em> <br></p>
																									   <p>[15] H. Chen, D. Wagner, and D. Dean. <em>Setuid Demystified.</em> 11th USENIX Security Symposium<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_privilege_management_setuid</key>
    <internalKey>API Abuse/Often Misused/Privilege Management(setuid)</internalKey>
    <name>Often Misused: Privilege Management(setuid)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Failure to adhere to the principle of least privilege amplifies the risk posed by other vulnerabilities.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Programs that run with <code>root</code> privileges have caused innumerable Unix security disasters. It is imperative that you carefully review privileged programs for all kinds of security problems, but it is equally important that privileged programs drop back to an unprivileged state as quickly as possible in order to limit the amount of damage that an overlooked vulnerability might be able to cause.<br><br><br>Privilege management functions can behave in some less-than-obvious ways, and they have different quirks on different platforms. These inconsistencies are particularly pronounced if you are transitioning from one non-<code>root</code> user to another.<br><br>Signal handlers and spawned processes run at the privilege of the owning process, so if a process is running as <code>root</code> when a signal fires or a sub-process is executed, the signal handler or sub-process will operate with root privileges. An attacker may be able to leverage these elevated privileges to do further damage.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-6 Least Privilege (P1)</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3500 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3500 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3500 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3500 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3500 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 250</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[10] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 250</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 250</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 7.1.1</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 7.1.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 7.1.2</em> <br></p>
																									   <p>[15] H. Chen, D. Wagner, and D. Dean. <em>Setuid Demystified.</em> 11th USENIX Security Symposium<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_strings__mbs</key>
    <internalKey>API Abuse/Often Misused/Strings(_mbs)</internalKey>
    <name>Often Misused: Strings(_mbs)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The <code>_mbs</code> family of functions is susceptible to buffer overflow when manipulating malformed multibyte strings.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Windows provides the <code>_mbs</code> family of functions to perform various operations on multibyte strings. When these functions are passed a malformed multibyte string, such as a string containing a valid leading byte followed by a single null byte, they can read or write past the end of the string buffer causing a buffer overflow. The following functions all pose a risk of buffer overflow:<br><br><pre><br>_mbsinc<br>_mbsdec<br>_mbsncat<br>_mbsncpy<br>_mbsnextc<br>_mbsnset<br>_mbsrev<br>_mbsset<br>_mbsstr<br>_mbstok<br>_mbccpy<br>_mbslen<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 176, CWE ID 251</em> <br></p>
																									   <p>[8]  <em>MBCS Programming Tips</em> Microsoft<br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[13] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_strings_multibytewidechar</key>
    <internalKey>API Abuse/Often Misused/Strings(multibytewidechar)</internalKey>
    <name>Often Misused: Strings(multibytewidechar)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Functions that convert between Multibyte and Unicode strings encourage buffer overflows.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Windows provides the <code>MultiByteToWideChar()</code>, <code>WideCharToMultiByte()</code>, <code>UnicodeToBytes()</code>, and <code>BytesToUnicode()</code> functions to convert between arbitrary multibyte (usually ANSI) character strings and Unicode (wide character) strings. The size arguments to these functions are specified in different units--one in bytes, the other in characters--making their use prone to error. In a multibyte character string, each character occupies a varying number of bytes, and therefore the size of such strings is most easily specified as a total number of bytes. In Unicode, however, characters are always a fixed size, and string lengths are typically given by the number of characters they contain. Mistakenly specifying the wrong units in a size argument can lead to a buffer overflow.<br><br><b>Example:</b> The following function takes a username specified as a multibyte string and a pointer to a structure for user information and populates the structure with information about the specified user. Since Windows authentication uses Unicode for usernames, the username argument is first converted from a multibyte string to a Unicode string.<br><br><pre><br>void getUserInfo(char *username, struct _USER_INFO_2 info){<br>WCHAR unicodeUser[UNLEN+1];<br>MultiByteToWideChar(CP_ACP, 0, username, -1,<br>     unicodeUser, sizeof(unicodeUser));<br>NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);<br>}<br></pre><br><br>This function incorrectly passes the size of <code>unicodeUser</code> in bytes instead of characters. The call to <code>MultiByteToWideChar()</code> can therefore write up to <code>(UNLEN+1)*sizeof(WCHAR</code>) wide characters, or (<code>UNLEN+1)*sizeof(WCHAR)*sizeof(WCHAR)</code> bytes, to the <code>unicodeUser</code> array, which has only <code>(UNLEN+1)*sizeof(WCHAR)</code> bytes allocated. If the <code>username</code> string contains more than <code>UNLEN</code> characters, the call to <code>MultiByteToWideChar()</code> will overflow the buffer <code>unicodeUser</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 176, CWE ID 251</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12]  <em>Security Considerations: International Features</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_unchecked_return_value</key>
    <internalKey>API Abuse/Unchecked Return Value</internalKey>
    <name>Unchecked Return Value</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Ignoring a method's return value can cause the program to overlook unexpected states and conditions.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.<br><br>Two dubious assumptions that are easy to spot in code are "this function call can never fail" and "it doesn't matter if this function call fails". When a programmer ignores the return value from a function, they implicitly state that they are operating under one of these assumptions.<br><br><b>Example:</b> Consider the following code:<br><br><pre><br>char buf[10], cp_buf[10];<br>fgets(buf, 10, stdin);<br>strcpy(cp_buf, buf);<br></pre><br><br>The programmer expects that when <code>fgets()</code> returns, <code>buf</code> will contain a null-terminated string of length 9 or less. But if an I/O error occurs, <code>fgets()</code> will not null-terminate <code>buf</code>. Furthermore, if the end of the file is reached before any characters are read, <code>fgets()</code> returns without writing anything to <code>buf</code>. In both of these situations, <code>fgets()</code> signals that something unusual has happened by returning <code>NULL</code>, but in this code, the warning will not be noticed. The lack of a null terminator in <code>buf</code> can result in a buffer overflow in the subsequent call to <code>strcpy()</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A7 Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II</em> <br></p>
																									   <p>[8] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[9] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 252, CWE ID 754</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.2, Requirement 6.5.6</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 754</em> <br></p>
																									   <p>[15] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-11 Error Handling (P2)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_arithmetic_operation_on_boolean</key>
    <internalKey>Code Quality/Code Correctness/Arithmetic Operation on Boolean</internalKey>
    <name>Code Correctness: Arithmetic Operation on Boolean</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program uses an arithmetic operator on a boolean value, which might not achieve what the programmer had in mind. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Arithmetic operations will not act in the same way on boolean values as they would on integral values, which may lead to unexpected behavior.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 398</em> <br></p>
																									   <p>[2] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_function_not_invoked</key>
    <internalKey>Code Quality/Code Correctness/Function Not Invoked</internalKey>
    <name>Code Correctness: Function Not Invoked</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Because it is missing trailing parentheses, this expression refers to the value of the function pointer rather than the return value of the function.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  This expression will always be non-null because it references a function pointer rather than the return value of the function.<br><br><b>Example 1:</b> The following conditional will never fire. The predicate <code>getChunk == NULL</code> will always be false because <code>getChunk</code> is the name of a function defined in the program.<br><br><pre><br>  if (getChunk == NULL)<br>    return ERR;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3050 CAT II</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3050 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3050 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3050 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3050 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 398</em> <br></p>
																									   <p>[7] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_function_returns_stack_address</key>
    <internalKey>Code Quality/Code Correctness/Function Returns Stack Address</internalKey>
    <name>Code Correctness: Function Returns Stack Address</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Returning the address of a stack variable will cause unintended program behavior, typically in the form of a crash.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced. The problem can be hard to debug because the cause of the problem is often far removed from the symptom.<br><br><b>Example 1:</b> The following function returns a stack address.<br><br><pre><br>char* getName() {<br>  char name[STR_MAX];<br>  fillInName(name);<br>  return name;<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 562</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_macro_misuse</key>
    <internalKey>Code Quality/Code Correctness/Macro Misuse</internalKey>
    <name>Code Correctness: Macro Misuse</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Families of functions that operate on shared resources and are implemented as macros on some platforms must be called in the same program scope.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Certain families of functions are implemented as functions on some platforms and macros on others. If the functions rely on a shared resource that is maintained internally rather than passed in when they are invoked, they must be used in the same program scope because the otherwise the shared resource will be inaccessible.<br><br><b>Example 1:</b> The following code uses <code>pthread_cleanup_push()</code> to push the function <code>routine</code> onto the calling thread's cleanup stack and returns. Because <code>pthread_cleanup_push()</code> and its partner function <code>pthread_cleanup_pop()</code> are implemented as macros on platforms other than IBM AIX, the data structure created by <code>pthread_cleanup_push()</code> will not be accessible to subsequent calls to <code>pthread_cleanup_pop()</code>. The code will either fail to compile or behave incorrectly at runtime on all platforms where these functions are implemented as macros.<br><br><pre><br>void helper() {<br>   ...<br>   pthread_cleanup_push (routine, arg);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 730</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[9] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_memory_free_on_stack_variable</key>
    <internalKey>Code Quality/Code Correctness/Memory Free on Stack Variable</internalKey>
    <name>Code Correctness: Memory Free on Stack Variable</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Freeing a stack buffer will result in unexpected program behavior.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Do not explicitly deallocate stack memory. A function that defines a stack buffer will automatically deallocate the buffer when the function returns.<br><br><b>Example:</b><br><pre><br>void clean_up()<br>{<br>    char tmp[256];<br>    ...<br>    free(tmp);<br>    return;<br>}<br></pre><br><br>Explicitly freeing stack memory can corrupt memory allocation data structures.  It can lead to abnormal program termination or further data corruption.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 730</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[9] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_premature_thread_termination</key>
    <internalKey>Code Quality/Code Correctness/Premature Thread Termination</internalKey>
    <name>Code Correctness: Premature Thread Termination</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  If a parent process finishes execution normally before the threads it has spawned, the threads can be terminated prematurely.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Threads spawned by calling <code>pthread_create()</code> from the <code>main()</code> function of the parent process will be terminated prematurely if the parent process finishes execution before any the threads it has spawned without calling <code>pthread_exit()</code>. Calling <code>pthread_exit()</code> guarantees that the parent process will be kept alive until all of its threads have finished execution. Alternatively, the parent process can call <code>pthread_join</code> on all of the child threads and ensure they will complete before the process concludes.<br><br><b>Example 1:</b> The following code uses <code>pthread_create()</code> to create a thread and then exits normally. If the child thread has not completed its execution by the time the <code>main()</code> function returns, then it will be terminated prematurely.<br><br><pre><br>void *Simple(void *threadid)<br>{<br>   ...<br>   pthread_exit(NULL);<br>}<br><br>int main(int argc, char *argv[]) {<br>   int rc;<br>   pthread_t pt;<br>   rc = pthread_create(&amp;pt, NULL, Simple, (void *)t);<br>   if (rc){<br>     exit(-1);<br>   }<br>}<br></pre>
							</p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_dead_code</key>
    <internalKey>Code Quality/Dead Code</internalKey>
    <name>Dead Code</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  This statement will never be executed.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The surrounding code makes it impossible for this statement to ever be executed.<br><br><b>Example:</b> The condition for the second <code>if</code> statement is impossible to satisfy. It requires that the variable <code>s</code> be non-null, while on the only path where <code>s</code> can be assigned a non-null value there is a <code>return</code> statement.<br><br><pre><br>String s = null;<br><br>if (b) {<br>   s = "Yes";<br>   return;<br>}<br><br>if (s != null) {<br>   Dead();<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3050 CAT II</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3050 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3050 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3050 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3050 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 561</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_double_free</key>
    <internalKey>Code Quality/Double Free</internalKey>
    <name>Double Free</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Calling <code>free()</code> twice on the same memory address can lead to a buffer overflow.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Double free errors occur when <code>free()</code> is called more than once with the same memory address as an argument.<br><br><br><br>Calling <code>free()</code> twice on the same value can lead to a buffer overflow. When a program calls <code>free()</code> twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to <code>malloc()</code> to return the same pointer. If <code>malloc()</code> returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.<br><br><b>Example 1:</b> The following code shows a simple example of a double free vulnerability.<br><br><pre><br>	char* ptr = (char*)malloc (SIZE);<br>	...<br>	if (abrt) {<br>	  free(ptr);<br>	}<br>	...<br>	free(ptr);<br></pre><br><br>Double free vulnerabilities have two common (and sometimes overlapping) causes:<br><br>- Error conditions and other exceptional circumstances.<br><br>- Confusion over which part of the program is responsible for freeing the memory.<br><br>Although some double free vulnerabilities are not much more complicated than the previous example, most are spread out across hundreds of lines of code or even different files. Programmers seem particularly susceptible to freeing global variables more than once.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 415</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_format_string_argument_number_mismatch</key>
    <internalKey>Code Quality/Format String/Argument Number Mismatch</internalKey>
    <name>Format String: Argument Number Mismatch</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							   The program uses an improperly constructed format string that contains a different number of conversion specifiers than the function has arguments. Incorrect format strings can lead the program to read data outside the bounds of allocated memory, which can allow access to sensitive information, introduce incorrect behavior, or crash the program.

							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br><br>In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br><br>Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including heap buffer overflows and off-by-one errors among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3].<br><br>At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily exceed the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br><br>In this case, an improperly constructed format string causes the program to access values outside the bounds of allocated memory.<br><br><b>Example:</b> The following reads arbitrary values from the stack because the number of format specifiers does not align with the number of arguments passed to the function.<br><pre><br>void wrongNumberArgs(char *s, float f, int d) {<br>   char buf[1024];<br>   sprintf(buf, &quot;Wrong number of %.512s&quot;);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[7] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 126</em> <br></p>
																									   <p>[9] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Format String Attack</em> <br></p>
																									   <p>[10] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 119</em> <br></p>
																									   <p>[16] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>
																									   <p>[17] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_format_string_argument_type_mismatch</key>
    <internalKey>Code Quality/Format String/Argument Type Mismatch</internalKey>
    <name>Format String: Argument Type Mismatch</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							   The program uses an improperly constructed format string that contains conversion specifiers that do not align with the types of the arguments passed to the function. Incorrect format strings can lead the program to convert values incorrectly and potentially read or write outside the bounds of allocated memory, which can introduce incorrect behavior or crash the program.

							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br><br>In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br><br>Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including heap buffer overflows and off-by-one errors among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3].<br><br>At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily exceed the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br><br>In this case, an improperly constructed format string causes the program to improperly convert data values or to access values outside the bounds of allocated memory.<br><br><b>Example:</b> The following code incorrectly converts <code>f</code> from a float using a <code>%d</code> format specifier.<br><br><pre><br>void ArgTypeMismatch(float f, int d, char *s, wchar *ws) {<br>   char buf[1024];<br>   sprintf(buf, &quot;Wrong type of %d&quot;, f);<br>   ...<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[7] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 787, CWE ID 125</em> <br></p>
																									   <p>[9] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Format String Attack</em> <br></p>
																									   <p>[10] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 119</em> <br></p>
																									   <p>[16] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>
																									   <p>[17] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_memory_leak</key>
    <internalKey>Code Quality/Memory Leak</internalKey>
    <name>Memory Leak</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Memory is allocated but never freed.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Memory leaks have two common and sometimes overlapping causes:<br><br>- Error conditions and other exceptional circumstances.<br><br>- Confusion over which part of the program is responsible for freeing the memory.<br><br>Most memory leaks result in general software reliability problems, but if an attacker can intentionally trigger a memory leak, the attacker may be able to launch a denial of service attack (by crashing the program) or take advantage of other unexpected program behavior resulting from a low memory condition [1].<br><br><b>Example 1:</b> The following C function leaks a block of allocated memory if the call to <code>read()</code> fails to return the expected number of bytes:<br><br><pre><br>  char* getBlock(int fd) {<br>  char* buf = (char*) malloc(BLOCK_SIZE);<br>  if (!buf) {<br>    return NULL;<br>  }<br>  if (read(fd, buf, BLOCK_SIZE) != BLOCK_SIZE) {<br>    return NULL;<br>  }<br>  return buf;<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 401</em> <br></p>
																									   <p>[8] J. Whittaker and H. Thompson <em>How to Break Software Security</em> Addison Wesley<br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_memory_leak_reallocation</key>
    <internalKey>Code Quality/Memory Leak/Reallocation</internalKey>
    <name>Memory Leak: Reallocation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program resizes a block of allocated memory. If the resize fails, the original block will be leaked.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Memory leaks have two common and sometimes overlapping causes:<br><br>- Error conditions and other exceptional circumstances.<br><br>- Confusion over which part of the program is responsible for freeing the memory.<br><br>Most memory leaks result in general software reliability problems, but if an attacker can intentionally trigger a memory leak, the attacker may be able to launch a denial of service attack (by crashing the program) or take advantage of other unexpected program behavior resulting from a low memory condition [1].<br><br><b>Example 1:</b> The following C function leaks a block of allocated memory if the call to <code>realloc()</code> fails to resize the original allocation.<br><br><pre><br>char* getBlocks(int fd) {<br>  int amt;<br>  int request = BLOCK_SIZE;<br>  char* buf = (char*) malloc(BLOCK_SIZE + 1);<br>  if (!buf) {<br>    goto ERR;<br>  }<br>  amt = read(fd, buf, request);<br>  while ((amt % BLOCK_SIZE) != 0) {<br>     if (amt &lt; request) {<br>        goto ERR;<br>     }<br>     request = request + BLOCK_SIZE;<br>     buf = realloc(buf, request);<br>     if (!buf) {<br>        goto ERR;<br>     }<br>     amt = read(fd, buf, request);<br>  }<br><br>  return buf;<br><br>  ERR:<br>  if (buf) {<br>    free(buf);<br>  }<br>  return NULL;<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 401</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[9] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_null_dereference</key>
    <internalKey>Code Quality/Null Dereference</internalKey>
    <name>Null Dereference</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program can potentially dereference a null pointer, thereby causing a segmentation fault.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Null pointer exceptions usually occur when one or more of the programmer's assumptions is violated. There are at least three flavors of this problem: check-after-dereference, dereference-after-check, and dereference-after-store. A check-after-dereference error occurs when a program dereferences a pointer that can be null before checking if the pointer is null. Dereference-after-check errors occur when a program makes an explicit check for null, but proceeds to dereference the pointer when it is known to be null. Errors of this type are often the result of a typo or programmer oversight. A dereference-after-store error occurs when a program explicitly sets a pointer to null and dereferences it later. This error is often the result of a programmer initializing a variable to null when it is declared.<br><br>Most null pointer issues result in general software reliability problems, but if an attacker can intentionally trigger a null pointer dereference, the attacker may be able to use the resulting exception to bypass security logic in order to mount a denial of service attack, or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.<br><br><b>Example 1:</b> In the following code, the programmer assumes that the variable <code>ptr</code> is not <code>NULL</code>.  That assumption is made explicit when the programmer dereferences the pointer.  This assumption is later contradicted when the programmer checks <code>ptr</code> against <code>NULL</code>. If <code>ptr</code> can be <code>NULL</code> when it is checked in the <code>if</code> statement then it can also be <code>NULL</code> when it dereferenced and may cause a segmentation fault.<br><br><pre><br>ptr-&gt;field = val;<br>...<br>if (ptr != NULL) {<br>	...<br>}<br></pre><br><br><b>Example 2:</b> In the following code, the programmer confirms that the variable <code>ptr</code> is <code>NULL</code> and subsequently dereferences it erroneously. If <code>ptr</code> is <code>NULL</code> when it is checked in the <code>if</code> statement, then a null dereference will occur, thereby causing a segmentation fault.<br><br><pre><br>if (ptr == null) {<br>        ptr-&gt;field = val;<br>        ...<br>}<br></pre><br><br><b>Example 3:</b> In the following code, the programmer forgets that the string <code>'\0'</code> is actually 0 or <code>NULL</code>, thereby dereferencing a null pointer and causing a segmentation fault.<br><br><pre><br>if (ptr == '\0') {<br>        *ptr = val;<br>        ...<br>}<br></pre><br><br><b>Example 4:</b> In the following code, the programmer explicitly sets the variable <code>ptr</code> to <code>NULL</code>. Later, the programmer dereferences <code>ptr</code> before checking the object for a null value.<br><br><pre><br>*ptr = NULL;<br>...<br>ptr-&gt;field = val;<br>...<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 476</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_obsolete</key>
    <internalKey>Code Quality/Obsolete</internalKey>
    <name>Obsolete</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The use of deprecated or obsolete functions could indicate neglected code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  As programming languages evolve, functions occasionally become obsolete due to:<br><br>- Advances in the language.<br><br>- Improved understanding of how operations should be performed effectively and securely.<br><br>- Changes in the conventions that govern certain operations.<br><br>Functions that are removed are usually replaced by newer counterparts that perform the same task in some different and hopefully improved way.<br><br><b>Example:</b> The following code uses the deprecated function <code>getpw()</code> to verify that a plaintext password matches a user's encrypted password. If the password is valid, the function sets <code>result</code> to 1; otherwise it is set to 0.<br><br><pre><br>	...<br>	getpw(uid, pwdline);<br>	for (i=0; i&lt;3; i++){<br>	cryptpw=strtok(pwdline, ":");<br>		pwdline=0;<br>	}<br>result = strcmp(crypt(plainpw,cryptpw), cryptpw) == 0;<br>	...<br></pre><br><br>Although the code often behaves correctly, using the <code>getpw(</code>) function can be problematic from a security standpoint, because it can overflow the buffer passed to its second parameter. Because of this vulnerability, <code>getpw()</code> has been supplanted by <code>getpwuid()</code>, which performs the same lookup as <code>getpw()</code> but returns a pointer to a statically-allocated structure to mitigate the risk.<br><br>Not all functions are deprecated or replaced because they pose a security risk. However, the presence of an obsolete function often indicates that the surrounding code has been neglected and may be in a state of disrepair. Software security has not been a priority, or even a consideration, for very long. If the program uses deprecated or obsolete functions, it raises the probability that there are security problems lurking nearby.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 477</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_obsolete_inadequate_pointer_validation</key>
    <internalKey>Code Quality/Obsolete/Inadequate Pointer Validation</internalKey>
    <name>Obsolete: Inadequate Pointer Validation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The function is obsolete and cannot guarantee that a pointer is valid or referenced memory is safe to use.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  There are a number of reasons not to use the <code>IsBadXXXPtr()</code> class of functions.  These functions are:<br>1) Not thread safe.<br>2) Often implicated in crashes caused by their probing of invalid memory addresses.<br>3) Erroneously believed to carry out proper error handling during exception conditions.<br><br><b>Example:</b> The following code uses <code>IsBadWritePtr()</code> in an attempt to prevent bad memory writes.<br><pre><br>if (IsBadWritePtr(ptr, length))<br>{<br>    [handle error]<br>}<br></pre><br><br>Programmers often use these functions intending that they will detect exception cases, but the functions usually cause more problems than they fix.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 730</em> <br></p>
																									   <p>[8]  <em>IsBadWritePtr Function</em> Microsoft<br></p>
																									   <p>[9] Raymond Chen <em>IsBadXxxPtr should really be called CrashProgramRandomly</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_poor_style_redundant_initialization</key>
    <internalKey>Code Quality/Poor Style/Redundant Initialization</internalKey>
    <name>Poor Style: Redundant Initialization</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The variable's value is assigned but never used, making it a dead store.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  This variable's initial value is not used. After initialization, the variable is either assigned another value or goes out of scope.<br><br><b>Example:</b> The following code excerpt assigns to the variable <code>r</code> and then overwrites the value without using it.<br><br><pre><br>  int r = getNum();<br>  r = getNewNum(buf);<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3050 CAT II</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3050 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3050 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3050 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3050 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 398</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_poor_style_value_never_read</key>
    <internalKey>Code Quality/Poor Style/Value Never Read</internalKey>
    <name>Poor Style: Value Never Read</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The variable's value is assigned but never used, making it a dead store.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  This variable's value is not used. After the assignment, the variable is either assigned another value or goes out of scope.<br><br><b>Example:</b> The following code excerpt assigns to the variable <code>r</code> and then overwrites the value without using it.<br><br><pre><br>  r = getName();<br>  r = getNewBuffer(buf);<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3050 CAT II</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3050 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3050 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3050 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3050 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 563</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_poor_style_variable_never_used</key>
    <internalKey>Code Quality/Poor Style/Variable Never Used</internalKey>
    <name>Poor Style: Variable Never Used</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  This variable is never used.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  This variable is never used. It is likely that the variable is simply vestigial, but it is also possible that the unused variable points out a bug.<br><br><b>Example:</b> In the following code, a copy-and-paste error has led to the same loop iterator (<code>i</code>) being used twice. The variable <code>j</code> is never used.<br><br><pre><br>  int i,j;<br><br>  for (i=0; i &lt; outer; i++) {<br>    for (i=0; i &lt; inner; i++) {<br>      ...<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3050 CAT II</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3050 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3050 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3050 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3050 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 563</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_portability_flaw</key>
    <internalKey>Code Quality/Portability Flaw</internalKey>
    <name>Portability Flaw</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Functions with inconsistent implementations across operating systems and operating system versions cause portability problems.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The behavior of functions in this category varies by operating system, and at times, even by operating system version. Implementation differences can include:<br><br>- Slight differences in the way parameters are interpreted leading to inconsistent results.<br><br>- Some implementations of the function carry significant security risks.<br><br>- The function might not be defined on all platforms.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 474</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_redundant_null_check</key>
    <internalKey>Code Quality/Redundant Null Check</internalKey>
    <name>Redundant Null Check</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program can potentially dereference a null pointer, thereby causing a segmentation fault.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Null pointer exceptions usually occur when one or more of the programmer's assumptions is violated. There are at least three flavors of this problem: check-after-dereference, dereference-after-check, and dereference-after-store. A check-after-dereference error occurs when a program dereferences a pointer that can be null before checking if the pointer is null. Dereference-after-check errors occur when a program makes an explicit check for null, but proceeds to dereference the pointer when it is known to be null. Errors of this type are often the result of a typo or programmer oversight. A dereference-after-store error occurs when a program explicitly sets a pointer to null and dereferences it later. This error is often the result of a programmer initializing a variable to null when it is declared.<br><br>Most null pointer issues result in general software reliability problems, but if an attacker can intentionally trigger a null pointer dereference, the attacker may be able to use the resulting exception to bypass security logic in order to mount a denial of service attack, or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.<br><br><b>Example 1:</b> In the following code, the programmer assumes that the variable <code>ptr</code> is not <code>NULL</code>.  That assumption is made explicit when the programmer dereferences the pointer.  This assumption is later contradicted when the programmer checks <code>ptr</code> against <code>NULL</code>. If <code>ptr</code> can be <code>NULL</code> when it is checked in the <code>if</code> statement then it can also be <code>NULL</code> when it dereferenced and may cause a segmentation fault.<br><br><pre><br>ptr-&gt;field = val;<br>...<br>if (ptr != NULL) {<br>        ...<br>}<br></pre><br><br><b>Example 2:</b> In the following code, the programmer confirms that the variable <code>ptr</code> is <code>NULL</code> and subsequently dereferences it erroneously. If <code>ptr</code> is <code>NULL</code> when it is checked in the <code>if</code> statement, then a null dereference will occur, thereby causing a segmentation fault.<br><br><pre><br>if (ptr == null) {<br>        ptr-&gt;field = val;<br>        ...<br>}<br></pre><br><br><b>Example 3:</b> In the following code, the programmer forgets that the string <code>'\0'</code> is actually 0 or <code>NULL</code>, thereby dereferencing a null pointer and causing a segmentation fault.<br><br><pre><br>if (ptr == '\0') {<br>        *ptr = val;<br>        ...<br>}<br></pre><br><br><b>Example 4:</b> In the following code, the programmer explicitly sets the variable <code>ptr</code> to <code>NULL</code>. Later, the programmer dereferences <code>ptr</code> before checking the object for a null value.<br><br><pre><br>*ptr = NULL;<br>...<br>ptr-&gt;field = val;<br>...<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 476</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[9] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_type_mismatch_integer_to_character</key>
    <internalKey>Code Quality/Type Mismatch/Integer to Character</internalKey>
    <name>Type Mismatch: Integer to Character</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The function returns an <code>unsigned char</code> cast to an <code>int</code>, but the return value is assigned to a <code>char</code> type.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  When an unsigned character cast to an integer is assign to a signed character, its value might be indistinguishable from <code>EOF</code>.<br><br><b>Example 1:</b> The code below reads a character and compares it to <code>EOF</code>.<br><br><pre><br>char c;<br><br>while ( (c = getchar()) != '\n' &amp;&amp; c != EOF ) {<br>  ...<br>}<br></pre><br><br>In this case, the return value from <code>getchar()</code> is cast to a <code>char</code> and compared to <code>EOF</code> (an <code>int</code>). Assuming <code>c</code> is a signed 8-bit value and <code>EOF</code> is a 32-bit signed value, then if <code>getchar()</code> returns a character represented by 0xFF, the value of <code>c</code> will be sign extended to 0xFFFFFFFF in the comparison to <code>EOF</code>. Since <code>EOF</code> is typically defined as -1 (0xFFFFFFFF), the loop will terminate erroneously.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3550 CAT I</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3550 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3550 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3550 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3550 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 398</em> <br></p>
																									   <p>[7]  <em>FIO34-C. Use int to capture the return value of character IO functions</em> CERT<br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_type_mismatch_negative_to_unsigned</key>
    <internalKey>Code Quality/Type Mismatch/Negative to Unsigned</internalKey>
    <name>Type Mismatch: Negative to Unsigned</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The function is declared to return an unsigned value, but in some cases it returns a negative value.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is dangerous to rely on implicit casts between signed and unsigned numbers because the result can take on an unexpected value and violate weak assumptions made elsewhere in the program.<br><br><b>Example:</b> In this example the variable <code>amount</code> can hold a negative value when it is returned. Because the function is declared to return an unsigned int, <code>amount</code> will be implicitly converted to unsigned.<br><br><pre><br>unsigned int readdata () {<br>	int amount = 0;<br>...<br>	if (result == ERROR)<br>		amount = -1;<br>	...<br>	return amount;<br>}<br></pre><br><br>If the error condition in the code above is met, then the return value of <code>readdata()</code> will be 4,294,967,295 on a system uses 32-bit integers.<br><br>Conversion between signed and unsigned values can lead to a variety of errors, but from a security standpoint is most commonly associated with integer overflow and buffer overflow vulnerabilities.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3550 CAT I</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3550 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3550 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3550 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3550 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 195</em> <br></p>
																									   <p>[7] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_type_mismatch_signed_to_unsigned</key>
    <internalKey>Code Quality/Type Mismatch/Signed to Unsigned</internalKey>
    <name>Type Mismatch: Signed to Unsigned</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The function is declared to return an unsigned number but returns a signed value.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is dangerous to rely on implicit casts between signed and unsigned numbers because the result can take on an unexpected value and violate weak assumptions made elsewhere in the program.<br><br><b>Example:</b> In this example, depending on the return value of <code>accecssmainframe()</code>, the variable <code>amount</code> can hold a negative value when it is returned. Because the function is declared to return an unsigned value, <code>amount</code> will be implicitly cast to an unsigned number.<br><br><pre><br>unsigned int readdata () {<br>	int amount = 0;<br>...<br>amount = accessmainframe();<br>...<br>	return amount;<br>}<br></pre><br><br>If the return value of <code>accessmainframe()</code> is -1, then the return value of <code>readdata()</code> will be 4,294,967,295 on a system that uses 32-bit integers.<br><br>Conversion between signed and unsigned values can lead to a variety of errors, but from a security standpoint is most commonly associated with integer overflow and buffer overflow vulnerabilities.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3550 CAT I</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3550 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3550 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3550 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3550 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 195</em> <br></p>
																									   <p>[7] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_undefined_behavior</key>
    <internalKey>Code Quality/Undefined Behavior</internalKey>
    <name>Undefined Behavior</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The behavior of this function is undefined unless its control parameter is set to a specific value.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The Linux Standard Base Specification 2.0.1 for libc places constraints on the arguments to some internal functions [1]. If the constraints are not met, the behavior of the functions is not defined.<br><br><br>The value <code>1</code> must be passed to the first parameter (the version number) of the following file system function:<br><br><pre><br>	__xmknod<br></pre><br><br>The value <code>2</code> must be passed to the third parameter (the group argument) of the following wide character string functions:<br><br><pre><br>__wcstod_internal<br>__wcstof_internal<br>_wcstol_internal<br>__wcstold_internal<br>__wcstoul_internal<br></pre><br><br>The value <code>3</code> must be passed as the first parameter (the version number) of the following file system functions:<br><br><pre><br>__xstat<br>__lxstat<br>__fxstat<br>__xstat64<br>__lxstat64<br>__fxstat64<br><br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 475</em> <br></p>
																									   <p>[2]  <em>The Linux Standard Base Specification 2.0.1, Interfaces Definitions for libc.</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_undefined_behavior_redundant_delete</key>
    <internalKey>Code Quality/Undefined Behavior/Redundant Delete</internalKey>
    <name>Undefined Behavior: Redundant Delete</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Explicitly deleting a managed pointer will cause the program to crash or otherwise misbehave.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Deleting a managed pointer will cause the program to crash or otherwise do the wrong thing when, later on, the pointer management code assumes that the pointer is still valid. The following example illustrates the error.<br><br><pre><br>  std::auto_ptr&lt;foo&gt; p(new foo);<br>  foo* rawFoo = p.get();<br>  delete rawFoo;<br></pre><br><br>The only exception to this rule comes when a managed pointer class supports a "detach" operation allowing the programmer to take control of memory management for the given pointer.  If the program detaches the pointer from the management class before calling <code>delete</code>, the management class knows not to use the pointer any further.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 730</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[9] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_uninitialized_variable</key>
    <internalKey>Code Quality/Uninitialized Variable</internalKey>
    <name>Uninitialized Variable</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program can potentially use a variable before it has been initialized.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Stack variables in C and C++ are not initialized by default. Their initial values are determined by whatever happens to be in their location on the stack at the time the function is invoked. Programs should never use the value of an uninitialized variable.<br><br>It is not uncommon for programmers to use an uninitialized variable in code that handles errors or other rare and exceptional circumstances. Uninitialized variable warnings can sometimes indicate the presence of a typographic error in the code.<br><br><b>Example 1:</b> The following switch statement is intended to set the values of the variables <code>aN</code> and <code>bN</code>, but in the default case, the programmer has accidentally set the value of <code>aN</code> twice.<br><br><pre><br>switch (ctl) {<br>  case -1:<br>    aN = 0; bN = 0;<br>    break;<br>  case 0:<br>    aN = i; bN = -i;<br>    break;<br>  case 1:<br>    aN = i + NEXT_SZ; bN = i - NEXT_SZ;<br>    break;<br>  default:<br>    <b>aN = -1; aN = -1;</b><br>    break;<br>}<br><br></pre><br><br>Most uninitialized variable issues result in general software reliability problems, but if attackers can intentionally trigger the use of an uninitialized variable, they might be able to launch a denial of service attack by crashing the program. Under the right circumstances, an attacker may be able to control the value of an uninitialized variable by affecting the values on the stack prior to the invocation of the function.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 457</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[9] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 665</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_unreleased_resource</key>
    <internalKey>Code Quality/Unreleased Resource</internalKey>
    <name>Unreleased Resource</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program can potentially fail to release a system resource.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The program can potentially fail to release a system resource.<br><br>Resource leaks have at least two common causes:<br><br>- Error conditions and other exceptional circumstances.<br><br>- Confusion over which part of the program is responsible for releasing the resource.<br><br>Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service by depleting the resource pool.<br><br><b>Example:</b> The following function does not close the file handle it opens if an error occurs. If the process is long-lived, the process can run out of file handles.<br><br><pre><br>int decodeFile(char* fName)<br>{<br>    char buf[BUF_SZ];<br>    FILE* f = fopen(fName, "r");<br><br>    if (!f) {<br>        printf("cannot open %s\n", fName);<br>        return DECODE_FAIL;<br>    } else {<br>        while (fgets(buf, BUF_SZ, f)) {<br>            if (!checkChecksum(buf)) {<br>              return DECODE_FAIL;<br>            } else {<br>              decodeBlock(buf);<br>            }<br>        }<br>    }<br>    fclose(f);<br>    return DECODE_SUCCESS;<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 404</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 404</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_unreleased_resource_synchronization</key>
    <internalKey>Code Quality/Unreleased Resource/Synchronization</internalKey>
    <name>Unreleased Resource: Synchronization</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program fails to release a lock it holds, which might lead to deadlock.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The program can potentially fail to release a system resource.<br><br>Resource leaks have at least two common causes:<br><br>- Error conditions and other exceptional circumstances.<br><br>- Confusion over which part of the program is responsible for releasing the resource.<br><br>Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service by depleting the resource pool.<br><br><b>Example:</b> The following function does destroy the condition variable it allocates if an error occurs. If the process is long-lived, the process can run out of file handles.<br><br><pre><br>int helper(char* fName)<br>{<br>   int status;<br>   ...<br>   pthread_cond_init (&amp;count_threshold_cv, NULL);<br>   pthread_mutex_init(&amp;count_mutex, NULL);<br><br>   status = perform_operation();<br>   if (status) {<br>      printf("%s", "cannot perform operation");<br>      return OPERATION_FAIL;<br>   }<br><br>   pthread_mutex_destroy(&amp;count_mutex);<br>   pthread_cond_destroy(&amp;count_threshold_cv);<br><br>   return OPERATION_SUCCESS;<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 411</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_use_after_free</key>
    <internalKey>Code Quality/Use After Free</internalKey>
    <name>Use After Free</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Referencing memory after it has been freed can cause a program to crash.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Use after free errors occur when a program continues to use a pointer after it has been freed. Like double free errors and memory leaks, use after free errors have two common and sometimes overlapping causes:<br><br>- Error conditions and other exceptional circumstances.<br><br>- Confusion over which part of the program is responsible for freeing the memory<br><br>Use after free errors sometimes have no effect and other times cause a program to crash. While it is technically feasible for the freed memory to be re-allocated and for an attacker to use this reallocation to launch a buffer overflow attack, we are unaware of any exploits based on this type of attack.<br><br><b>Example:</b> The following code illustrates a use after free error:<br><br><pre><br>char* ptr = (char*)malloc (SIZE);<br>...<br>if (err) {<br>    abrt = 1;<br>    free(ptr);<br>}<br>...<br>if (abrt) {<br>    logError("operation aborted before commit", ptr);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 416</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>encapsulation_system_information_leak</key>
    <internalKey>Encapsulation/System Information Leak</internalKey>
    <name>System Information Leak</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.<br><br><b>Example:</b> The following code prints the path environment variable to the standard error stream:<br><br><pre><br>  char* path = getenv("PATH");<br>  ...<br>  sprintf(stderr, "cannot find exe on path %s\n", path);<br></pre><br><br>Depending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. For example, with scripting mechanisms it is trivial to redirect output information from &quot;Standard error&quot; or &quot;Standard output&quot; into a file or another program. Alternatively the system that the program runs on could have a remote logging mechanism such as a &quot;syslog&quot; server that will send the logs to a remote device. During development you will have no way of knowing where this information may end up being displayed.<br><br>In some cases the error message tells the attacker precisely what sort of an attack the system will be vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 497</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_system_information_leak_external</key>
    <internalKey>Encapsulation/System Information Leak/External</internalKey>
    <name>System Information Leak: External</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  An external information leak occurs when system data or debugging information leaves the program to a remote machine via a socket or network connection.<br><br><b>Example:</b> The following code leaks system information via a socket:<br><br><pre><br>  int sockfd;<br>  int flags;<br>  char hostname[1024];<br>  hostname[1023] = '\0';<br>  gethostname(hostname, 1023);<br>  ...<br>  sockfd = socket(AF_INET, SOCK_STREAM, 0);<br>  flags = 0;<br>  send(sockfd, hostname, strlen(hostname), flags);<br></pre><br><br>This information can be exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 497</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_system_information_leak_internal</key>
    <internalKey>Encapsulation/System Information Leak/Internal</internalKey>
    <name>System Information Leak: Internal</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  An internal information leak occurs when system data or debugging information is sent via logging or printing to a local file, console, or screen.<br><br><b>Example:</b> The following code prints an error to the standard error stream:<br><br><pre><br>if (!fileInput.Open(PATH, CFile::modeRead, &amp;ex)) {<br>    ex.ReportError();<br>} else {<br>    fileInput.Close();<br>}<br></pre><br><br>Depending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 497</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>environment_insecure_compiler_optimization</key>
    <internalKey>Environment/Insecure Compiler Optimization</internalKey>
    <name>Insecure Compiler Optimization</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Improperly scrubbing sensitive data from memory can compromise security.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Compiler optimization errors occur when:<br><br>1. Secret data is stored in memory.<br><br>2. The secret data is scrubbed from memory by overwriting its contents.<br><br><br><br>3. The source code is compiled using an optimizing compiler, which identifies and removes the function that overwrites the contents as a dead store because the memory is not used subsequently.<br><br><b>Example:</b> The following code reads a password from the user, uses the password to connect to a back-end mainframe and then attempts to scrub the password from memory using <code>memset()</code>.<br><br><pre><br>  void GetData(char *MFAddr) {<br>  char pwd[64];<br>  if (GetPasswordFromUser(pwd, sizeof(pwd))) {<br>   if (ConnectToMainframe(MFAddr, pwd)) {<br>		 // Interaction with mainframe<br>	 }<br>  }<br>  memset(pwd, 0, sizeof(pwd));<br>}<br></pre><br><br>The code in the example will behave correctly if it is executed verbatim, but if the code is compiled using an optimizing compiler, such as Microsoft Visual C++(R) .NET or GCC 3.x, then the call to <code>memset()</code> will be removed as a dead store because the buffer <code>pwd</code> is not used after its value is overwritten [2]. Because the buffer <code>pwd</code> contains a sensitive value, the application may be vulnerable to attack if the data is left memory resident. If attackers are able to access the correct region of memory, they may use the recovered password to gain control of the system.<br><br>It is common practice to overwrite sensitive data manipulated in memory, such as passwords or cryptographic keys, in order to prevent attackers from learning system secrets. However, with the advent of optimizing compilers, programs do not always behave as their source code alone would suggest. In the example, the compiler interprets the call to <code>memset()</code> as dead code because the memory being written to is not subsequently used, despite the fact that there is clearly a security motivation for the operation to occur. The problem here is that many compilers, and in fact many programming languages, do not take this and other security concerns into consideration in their efforts to improve efficiency.<br><br>Attackers typically exploit this type of vulnerability by using a core dump or runtime mechanism to access the memory used by a particular application and recover the secret information. Once an attacker has access to the secret information, it is relatively straightforward to further exploit the system and possibly compromise other resources with which the application interacts.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 14</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[12] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-4 Information in Shared Resources (P1)</em> <br></p>
																									   <p>[18] M. Howard <em>Some Bad News and Some Good News</em> Microsoft<br></p>
																									   <p>[19] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_insecure_compiler_optimization_pointer_arithmetic</key>
    <internalKey>Environment/Insecure Compiler Optimization/Pointer Arithmetic</internalKey>
    <name>Insecure Compiler Optimization: Pointer Arithmetic</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Array bounds check could be mistakenly optimized out.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  If an array bounds check involves computing an illegal pointer and then determining that the pointer is out of bounds, some compilers will optimize the check away, assuming that the programmer would never intentionally create an illegal pointer.<br><br><b>Example:</b><br><pre><br>  char *buf;<br>  int len;<br>  ...<br>  len = 1&lt;&lt;30;<br><br>  if (buf+len &lt; buf)  //wrap check<br>    [handle overflow]<br></pre><br><br>The operation <code>buf + len</code> is larger than <code>2^32</code>, so the resulting value is smaller than <code>buf</code>.  But since an arithmetic overflow on a pointer is undefined behavior, some compilers will assume <code>buf + len &gt;= buf</code> and optimize away the wrap check. As a result of this optimization, code following this block could be vulnerable to buffer overflow.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3590.1 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 733</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[13] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-4 Information in Shared Resources (P1)</em> <br></p>
																									   <p>[14]  <em>Vulnerability Note VU#162289</em> CERT<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_buffer_overflow</key>
    <internalKey>Input Validation and Representation/Buffer Overflow</internalKey>
    <name>Buffer Overflow</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program writes outside the bounds of allocated memory, which could corrupt data, crash the program, or lead to the execution of malicious code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br><br>In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br><br>Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including heap buffer overflows and off-by-one errors among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3].<br><br>At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily overwrite the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br><br>Buffer overflow vulnerabilities typically occur in code that:<br><br>- Relies on external data to control its behavior.<br><br>- Depends upon properties of the data that are enforced outside of the immediate scope of the code.<br><br>- Is so complex that a programmer cannot accurately predict its behavior.<br><br><br><br>The following examples demonstrate all three of the scenarios.<br><br><b>Example 1:</b> This is an example of the second scenario in which the code depends on properties of the data that are not verified locally. In this example a function named <code>lccopy()</code> takes a string as its argument and returns a heap-allocated copy of the string with all uppercase letters converted to lowercase. The function performs no bounds checking on its input because it expects <code>str</code> to always be smaller than <code>BUFSIZE</code>. If an attacker bypasses checks in the code that calls <code>lccopy()</code>, or if a change in that code makes the assumption about the size of <code>str</code> untrue, then <code>lccopy()</code> will overflow <code>buf</code> with the unbounded call to <code>strcpy()</code>.<br><br><pre><br>char *lccopy(const char *str) {<br>	char buf[BUFSIZE];<br>	char *p;<br><br>	strcpy(buf, str);<br>	for (p = buf; *p; p++) {<br>		if (isupper(*p)) {<br>			*p = tolower(*p);<br>		}<br>	}<br>	return strdup(buf);<br>}<br></pre><br><br><b>Example 2.a:</b> The following sample code demonstrates a simple buffer overflow that is often caused by the first scenario in which the code  relies on external data to control its behavior. The code uses the <code>gets()</code> function to read an arbitrary amount of data into a stack buffer. Because there is no way to limit the amount of data read by this function, the safety of the code depends on the user to always enter fewer than <code>BUFSIZE</code> characters.<br><br><pre><br>	...<br>	char buf[BUFSIZE];<br>	gets(buf);<br>	...<br></pre><br><br><b>Example 2.b:</b> This example shows how easy it is to mimic the unsafe behavior of the <code>gets()</code> function in C++ by using the <code>&gt;&gt;</code> operator to read input into a <code>char[]</code> string.<br><br><pre><br>	...<br>	char buf[BUFSIZE];<br>	cin &gt;&gt; (buf);<br>	...<br></pre><br><br><b>Example 3:</b> The code in this example also relies on user input to control its behavior, but it adds a level of indirection with the use of the bounded memory copy function <code>memcpy()</code>. This function accepts a destination buffer, a source buffer, and the number of bytes to copy. The input buffer is filled by a bounded call to <code>read()</code>, but the user specifies the number of bytes that <code>memcpy()</code> copies.<br><br><pre><br>	...<br>char buf[64], in[MAX_SIZE];<br>printf("Enter buffer contents:\n");<br>read(0, in, MAX_SIZE-1);<br>printf("Bytes to copy:\n");<br>scanf("%d", &amp;bytes);<br>memcpy(buf, in, bytes);<br>	...<br></pre><br><br>Note: This type of buffer overflow vulnerability (where a program reads data and then trusts a value from the data in subsequent memory operations on the remaining data) has turned up with some frequency in image, audio, and other file processing libraries.<br><br><b>Example 4:</b> The following code demonstrates the third scenario in which the code is so complex its behavior cannot be easily predicted. This code is from the popular libPNG image decoder, which is used by a wide array of applications, including Mozilla and some versions of Internet Explorer.<br><br>The code appears to safely perform bounds checking because it checks the size of the variable length, which it later uses to control the amount of data copied by <code>png_crc_read()</code>. However, immediately before it tests length, the code performs a check on <code>png_ptr-&gt;mode</code>, and if this check fails a warning is issued and processing continues. Because <code>length</code> is tested in an <code>else if</code> block, <code>length</code> would not be tested if the first check fails, and is used blindly in the call to <code>png_crc_read()</code>, potentially allowing a stack buffer overflow.<br><br>Although the code in this example is not the most complex we have seen, it demonstrates why complexity should be minimized in code that performs memory operations.<br><br><pre><br>if (!(png_ptr-&gt;mode &amp; PNG_HAVE_PLTE)) {<br>	/* Should be an error, but we can cope with it */<br>png_warning(png_ptr, "Missing PLTE before tRNS");<br>}<br>else if (length &gt; (png_uint_32)png_ptr-&gt;num_palette) {<br>png_warning(png_ptr, "Incorrect tRNS chunk length");<br>png_crc_finish(png_ptr, length);<br>return;<br>}<br>...<br>png_crc_read(png_ptr, readbuf, (png_size_t)length);<br></pre><br><br><b>Example 5:</b> This example also demonstrates the third scenario in which the program's complexity exposes it to buffer overflows. In this case, the exposure is due to the ambiguous interface of one of the functions rather than the structure of the code (as was the case in the previous example).<br><br>The <code>getUserInfo()</code> function takes a username specified as a multibyte string and a pointer to a structure for user information, and populates the structure with information about the user. Since Windows authentication uses Unicode for usernames, the <code>username</code> argument is first converted from a multibyte string to a Unicode string. This function then incorrectly passes the size of <code>unicodeUser</code> in bytes rather than characters. The call to <code>MultiByteToWideChar()</code> may therefore write up to <code>(UNLEN+1)*sizeof(WCHAR)</code> wide characters, or<br><code>(UNLEN+1)*sizeof(WCHAR)*sizeof(WCHAR)</code> bytes, to the <code>unicodeUser</code> array, which has only <code>(UNLEN+1)*sizeof(WCHAR)</code> bytes allocated. If the <code>username</code> string contains more than <code>UNLEN</code> characters, the call to <code>MultiByteToWideChar()</code> will overflow the buffer <code>unicodeUser</code>.<br><br><pre><br>void getUserInfo(char *username, struct _USER_INFO_2 info){<br>WCHAR unicodeUser[UNLEN+1];<br>	MultiByteToWideChar(CP_ACP, 0, username, -1,<br>    	      			unicodeUser, sizeof(unicodeUser));<br>NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Buffer Overflow</em> <br></p>
																									   <p>[8] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[9] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 787, CWE ID 120, CWE ID 129, CWE ID 131</em> <br></p>
																									   <p>[10] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 119</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 120, Risky Resource Management - CWE ID 129, Risky Resource Management - CWE ID 131</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 120, Risky Resource Management - CWE ID 131</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[19] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>
																									   <p>[20] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_buffer_overflow_format_string</key>
    <internalKey>Input Validation and Representation/Buffer Overflow/Format String</internalKey>
    <name>Buffer Overflow: Format String</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program uses an improperly bounded format string, allowing it to write outside the bounds of allocated memory. This behavior could corrupt data, crash the program, or lead to the execution of malicious code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br><br>In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br><br>Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including heap buffer overflows and off-by-one errors among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3].<br><br>At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily exceed the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br><br>In this case, an improperly constructed format string causes the program to write beyond the bounds of allocated memory.<br><br><b>Example:</b> The following code overflows <code>c</code> because the <code>double</code> type requires more space than is allocated for <code>c</code>.<br><br><pre><br>void formatString(double d) {<br>    char c;<br><br>    scanf("%d", &amp;c)<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3560 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3560 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3560 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3560 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3560 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[7] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 787, CWE ID 134</em> <br></p>
																									   <p>[9] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Format String Attack</em> <br></p>
																									   <p>[10] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 119</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 134</em> <br></p>
																									   <p>[17] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>
																									   <p>[18] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_buffer_overflow_format_string___f__f</key>
    <internalKey>Input Validation and Representation/Buffer Overflow/Format String (%f/%F)</internalKey>
    <name>Buffer Overflow: Format String (%f/%F)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program uses an improperly bounded format string that includes a %f or %F floating point specifier. Unexpectedly large floating point values will lead the program to write data outside the bounds of allocated memory, which can corrupt data, crash the program, or lead to the execution of malicious code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br><br>In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br><br>Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including heap buffer overflows and off-by-one errors among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3].<br><br>At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily exceed the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br><br>In this case, an improperly constructed format string causes the program to write beyond the bounds of allocated memory.<br><br><b>Example:</b> The following code overflows <code>buf</code> because, depending on the size of <code>f</code>, the format string specifier <code>&quot;%d %.1f ... &quot;</code> can exceed the amount of allocated memory.<br><br><pre><br>void formatString(int x, float f) {<br>   char buf[40];<br>   sprintf(buf, &quot;%d %.1f ... &quot;, x, f);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3560 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3560 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3560 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3560 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3560 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[7] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 787</em> <br></p>
																									   <p>[9] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Format String Attack</em> <br></p>
																									   <p>[10] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 119</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 134</em> <br></p>
																									   <p>[17] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>
																									   <p>[18] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_buffer_overflow_off_by_one</key>
    <internalKey>Input Validation and Representation/Buffer Overflow/Off-by-One</internalKey>
    <name>Buffer Overflow: Off-by-One</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program writes just past the bounds of allocated memory, which could corrupt data, crash the program, or lead to the execution of malicious code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br><br>In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br><br>Although this type of off-by-one error is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including stack and heap buffer overflows among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3].<br><br>At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily exceed the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br><br><b>Example:</b> The following code contains an off-by-one buffer overflow, which occurs when <code>recv</code> returns the maximum allowed <code>sizeof(buf)</code> bytes read. In this case, the subsequent dereference of <code>buf[nbytes]</code> will write the null byte outside the bounds of allocated memory.<br><br><pre><br>void receive(int socket) {<br>   char buf[MAX];<br>   int nbytes = recv(socket, buf, sizeof(buf), 0);<br>   buf[nbytes] = '\0';<br>   ...<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Buffer Overflow</em> <br></p>
																									   <p>[8] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[9] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 787, CWE ID 193, CWE ID 805, CWE ID 129, CWE ID 131</em> <br></p>
																									   <p>[10] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 119</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 131</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 805, Risky Resource Management - CWE ID 129, Risky Resource Management - CWE ID 131</em> <br></p>
																									   <p>[18] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>
																									   <p>[19] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_buffer_overflow_signed_comparison</key>
    <internalKey>Input Validation and Representation/Buffer Overflow/Signed Comparison</internalKey>
    <name>Buffer Overflow: Signed Comparison</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program uses a signed comparison to check a value that is later treated as unsigned. This could lead the program to write outside the bounds of allocated memory, which could corrupt data, crash the program, or lead to the execution of malicious code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br><br>In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br><br>Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including heap buffer overflows and off-by-one errors among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3].<br><br>At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily exceed the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br><br><b>Example:</b> The following code attempts to prevent an off-by-one buffer overflow by checking that the untrusted value read from <code>getInputLength()</code> is less than the size of the destination buffer <code>output</code>. However, because the comparison between <code>len</code> and <code>MAX</code> is signed, if <code>len</code> is negative, it will be become a very large positive number when it is converted to an unsigned argument to <code>memcpy()</code>.<br><br><pre><br>void TypeConvert() {<br>   char input[MAX];<br>   char output[MAX];<br><br>   fillBuffer(input);<br>   int len = getInputLength();<br><br>   if (len &lt;= MAX) {<br>      memcpy(output, input, len);<br>   }<br>   ...<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3550 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3550 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3550 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3550 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3550 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Buffer Overflow</em> <br></p>
																									   <p>[8] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[9] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 195, CWE ID 805</em> <br></p>
																									   <p>[10] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 805</em> <br></p>
																									   <p>[16] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>
																									   <p>[17] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_command_injection</key>
    <internalKey>Input Validation and Representation/Command Injection</internalKey>
    <name>Command Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Executing commands without specifying an absolute path could allow an attacker to execute a malicious binary by changing <code>$PATH</code> or other aspects of the program's execution environment.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Command injection vulnerabilities take two forms:<br><br>- An attacker can change the command that the program executes: the attacker explicitly controls what the command is.<br><br>- An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means.<br><br>In this case we are primarily concerned with the second scenario, in which an attacker can change the meaning of the command by changing an environment variable or by inserting a malicious executable early on the search path. Command injection vulnerabilities of this type occur when:<br><br>1. An attacker modifies an application's environment.<br><br>2. The application executes a command without specifying an absolute path or verifying the binary being executed.<br><br><br><br>3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have.<br><br><b>Example 1:</b> This example demonstrates what can happen when the attacker can change how a command is interpreted. The code is from a web-based CGI utility that allows users to change their passwords. The password update process under NIS includes running <code>make</code> in the <code>/var/yp</code> directory. Note that since the program updates password records, it has been installed <code>setuid root</code>.<br><br>The program invokes <code>make</code> as follows:<br><br><pre><br>system("cd /var/yp &amp;&amp; make &amp;&gt; /dev/null");<br></pre><br><br>The command in this example is hard-coded, so an attacker cannot control the argument passed to <code>system()</code>. However, since the program does not specify an absolute path for <code>make</code> and does not scrub its environment variables prior to invoking the command, the attacker can modify their <code>$PATH</code> variable to point to a malicious binary named <code>make</code> and execute the CGI script from a shell prompt. And since the program has been installed <code>setuid root</code>, the attacker's version of <code>make</code> now runs with <code>root</code> privileges.<br><br>On Windows, additional risks are present.<br><br><b>Example 2:</b> When invoking <code>CreateProcess()</code> either directly or via a call to one of the functions in the <code>_spawn()</code> family, care must be taken when there is a space in an executable or path.<br><br><pre><br>...<br>LPTSTR cmdLine = _tcsdup(TEXT("C:\\Program Files\\MyApplication -L -S"));<br>CreateProcess(NULL, cmdLine, ...);<br>...<br></pre><br><br>Because of the way <code>CreateProcess()</code> parses spaces, the first executable the operating system will try to execute is <code>Program.exe</code>, not <code>MyApplication.exe</code>. Therefore, if an attacker is able to install a malicious application called <code>Program.exe</code> on the system, any program that incorrectly calls <code>CreateProcess()</code> using the <code>Program Files</code> directory will run this application instead of the intended one.<br><br>The environment plays a powerful role in the execution of system commands within programs. Functions like <code>system()</code>, <code>exec()</code>, and <code>CreateProcess()</code> use the environment of the program that calls them, and therefore attackers have a potential opportunity to influence the behavior of these calls.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 77, CWE ID 78</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 078</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 078</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 116</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[15] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>OS Commanding</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_denial_of_service</key>
    <internalKey>Input Validation and Representation/Denial of Service</internalKey>
    <name>Denial of Service</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An attacker could cause the program to crash or otherwise become unavailable to legitimate users.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Attackers may be able to deny service to legitimate users by flooding the application with requests, but flooding attacks can often be defused at the network layer. More problematic are bugs that allow an attacker to overload the application using a small number of requests. Such bugs allow the attacker to specify the quantity of system resources their requests will consume or the duration for which they will use them.<br><br><b>Example 1:</b> The following code allows a user to specify the amount of time for which the current process will sleep. By specifying a large number, an attacker can tie up the process indefinitely.<br><br><pre><br>  unsigned int usrSleepTime = uatoi(usrInput);<br>  sleep(usrSleepTime);<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 730</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Denial of Service</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_format_string</key>
    <internalKey>Input Validation and Representation/Format String</internalKey>
    <name>Format String</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Allowing an attacker to control a function's format string can result in a buffer overflow.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Format string vulnerabilities occur when an attacker is allowed to control the format string argument to a function like <code>sprintf()</code>, <code>FormatMessageW()</code>, or <code>syslog()</code>.<br><br><br><br><b>Example 1:</b> The following code copies a command line argument into a buffer using <code>snprintf()</code>.<br><br><pre><br>int main(int argc, char **argv){<br>	char buf[128];<br>	...<br>	snprintf(buf,128,argv[1]);<br>}<br></pre><br><br>This code allows an attacker to view the contents of the stack and write to the stack using a command line argument containing a sequence of formatting directives. The attacker can read from the stack by providing more formatting directives, such as <code>%x</code>, than the function takes as arguments to be formatted. (In this example, the function takes no arguments to be formatted.) By using the <code>%n</code> formatting directive, the attacker can write to the stack, causing <code>snprintf()</code> to write the number of bytes output thus far to the specified argument (rather than reading a value from the argument, which is the intended behavior). A sophisticated version of this attack will use four staggered writes to completely control the value of a pointer on the stack.<br><br><b>Example 2:</b> Certain implementations make more advanced attacks even easier by providing format directives that control the location in memory to read from or write to. An example of these directives is shown in the following code, written for glibc:<br><br><pre><br>	printf("%d %d %1$d %1$d\n", 5, 9);<br></pre><br><br>This code produces the following output:<br><br><pre><br>5 9 5 5<br></pre><br><br>It is also possible to use half-writes (%hn) to accurately control arbitrary DWORDS in memory, which greatly reduces the complexity needed to execute an attack that would otherwise require four staggered writes, such as the one mentioned in Example 1.<br><br><b>Example 3:</b> Simple format string vulnerabilities often result from seemingly innocuous shortcuts. The use of some such shortcuts is so ingrained that programmers might not even realize that the function they are using expects a format string argument.<br><br>For example, the <code>syslog()</code> function is sometimes used as follows:<br><br><pre><br>	...<br>syslog(LOG_ERR, cmdBuf);<br>	...<br></pre><br><br>Because the second parameter to <code>syslog()</code> is a format string, any formatting directives included in <code>cmdBuf</code> are interpreted as described in Example 1.<br><br>The following code shows a correct usage of <code>syslog()</code>:<br><br><pre><br>	...<br> 	syslog(LOG_ERR, "%s", cmdBuf);<br>...<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3560 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 134</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Format String Attack</em> <br></p>
																									   <p>[9] T. Newsham <em>Format String Attacks</em> Guardent, Inc.<br></p>
																									   <p>[10] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 134</em> <br></p>
																									   <p>[16] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_illegal_pointer_value</key>
    <internalKey>Input Validation and Representation/Illegal Pointer Value</internalKey>
    <name>Illegal Pointer Value</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  This function can return a pointer to memory outside of the buffer to be searched. Subsequent operations on the pointer can have unintended consequences.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 466</em> <br></p>
																									   <p>[8] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 119</em> <br></p>
																									   <p>[14] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_integer_overflow</key>
    <internalKey>Input Validation and Representation/Integer Overflow</internalKey>
    <name>Integer Overflow</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Not accounting for integer overflow can result in logic errors or buffer overflow.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Integer overflow errors occur when a program fails to account for the fact that an arithmetic operation can result in a quantity either greater than a data type's maximum value or less than its minimum value. These errors often cause problems in memory allocation functions, where user input intersects with an implicit conversion between signed and unsigned values. If an attacker can cause the program to under-allocate memory or interpret a signed value as an unsigned value in a memory operation, the program may be vulnerable to a buffer overflow.<br><br><b>Example 1:</b> The following code excerpt from OpenSSH 3.3 demonstrates a classic case of integer overflow:<br><br><pre><br>nresp = packet_get_int();<br>if (nresp &gt; 0) {<br> response = xmalloc(nresp*sizeof(char*));<br> for (i = 0; i &lt; nresp; i++)<br>  response[i] = packet_get_string(NULL);<br>}<br></pre><br><br>If <code>nresp</code> has the value <code>1073741824</code> and <code>sizeof(char*)</code> has its typical value of <code>4</code>, then the result of the operation <code>nresp*sizeof(char*)</code> overflows, and the argument to <code>xmalloc()</code> will be <code>0</code>. Most <code>malloc()</code> implementations will allow for the allocation of a 0-byte buffer, causing the subsequent loop iterations to overflow the heap buffer <code>response</code>.<br><br><b>Example 2:</b> This example processes user input comprised of a series of variable-length structures. The first 2 bytes of input dictate the size of the structure to be processed.<br><br><pre><br> char* processNext(char* strm) {<br> char buf[512];<br> short len = *(short*) strm;<br> strm += sizeof(len);<br> if (len &lt;= 512) {<br>  memcpy(buf, strm, len);<br>  process(buf);<br>  return strm + len;<br> } else {<br>  return -1;<br> }<br>}<br></pre><br><br>The programmer has set an upper bound on the structure size: if it is larger than <code>512</code>, the input will not be processed. The problem is that <code>len</code> is a signed integer, so the check against the maximum structure length is done with signed integers, but <code>len</code> is converted to an unsigned integer for the call to <code>memcpy()</code>. If <code>len</code> is negative, then it will appear that the structure has an appropriate size (the <code>if</code> branch will be taken), but the amount of memory copied by <code>memcpy()</code> will be quite large, and the attacker will be able to overflow the stack with data in <code>strm</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3550 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3550 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3550 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3550 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3550 CAT I</em> <br></p>
																									   <p>[7] blexim <em>Basic Integer Overflows</em> Phrack<br></p>
																									   <p>[8] D. Plakosh <em>Coding Flaws That Lead to Security Failures</em> <br></p>
																									   <p>[9] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 190</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1, Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 190</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 190</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 682</em> <br></p>
																									   <p>[17] Les Hatton <em>Safer C: Developing Software for High-integrity and Safety-critical Systems</em> McGraw-Hill Companies<br></p>
																									   <p>[18] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_ldap_injection</key>
    <internalKey>Input Validation and Representation/LDAP Injection</internalKey>
    <name>LDAP Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Constructing a dynamic LDAP filter with user input could allow an attacker to modify the statement's meaning.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  LDAP injection errors occur when:<br><br>1.	Data enters a program from an untrusted source.<br><br>In this case HP Fortify Static Code Analyzer could not determine that the source of the data is trusted.<br><br>2.	The data is used to dynamically construct a LDAP filter.<br><br><b>Example 1:</b> The following code dynamically constructs and executes an LDAP query that retrieves records for all the employees who report to a given manager. The manager's name is read from a network socket, and is therefore untrusted.<br><br><pre><br>fgets(manager, sizeof(manager), socket);<br><br>snprintf(filter, sizeof(filter, "(manager=%s)", manager);<br><br>if ( ( rc = ldap_search_ext_s( ld, FIND_DN, LDAP_SCOPE_BASE,<br>       filter, NULL, 0, NULL, NULL, LDAP_NO_LIMIT,<br>       LDAP_NO_LIMIT, &amp;result ) ) == LDAP_SUCCESS ) {<br>  ...<br></pre><br><br>Under normal conditions, such as searching for employees who report to the manager John Smith, the filter that this code executes will look like the following:<br><br><pre><br>(manager=Smith, John)<br></pre><br><br>However, because the filter is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>manager</code> does not contain any LDAP meta characters. If an attacker enters the string <code>Hacker, Wiley)(|(objectclass=*)</code> for <code>manager</code>, then the query becomes the following:<br><br><pre><br>(manager=Hacker, Wiley)(|(objectclass=*))<br></pre><br><br>Based on the permissions with which the query is executed, the addition of the <code>|(objectclass=*)</code> condition causes the filter to match against all entries in the directory, and allows the attacker to retrieve information about the entire pool of users. Depending on the permissions with which the LDAP query is performed, the breadth of this attack may be limited, but if the attacker can control the command structure of the query, such an attack can at least affect all records that the user the LDAP query is executed as can access.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 90</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 116</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>LDAP Injection</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[18] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_ldap_manipulation</key>
    <internalKey>Input Validation and Representation/LDAP Manipulation</internalKey>
    <name>LDAP Manipulation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Executing an LDAP statement that contains a user-controlled value outside the filter string can allow an attacker to alter the statement's meaning or execute arbitrary LDAP commands.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  LDAP manipulation errors occur when:<br><br>1.	Data enters a program from an untrusted source.<br><br>2.	The data is used outside the filter string in a dynamic LDAP statement.<br><br><b>Example 1:</b> The following code reads a <code>dn</code> string from a socket and uses it to perform an LDAP query.<br><br><pre><br>...<br>rc = ldap_simple_bind_s( ld, NULL, NULL );<br>  if ( rc != LDAP_SUCCESS ) {<br>    ...<br>  }<br>...<br><br>fgets(dn, sizeof(dn), socket);<br><br>if ( ( rc = ldap_search_ext_s( ld, dn, LDAP_SCOPE_BASE,<br>                               filter, NULL, 0, NULL, NULL, LDAP_NO_LIMIT,<br>                               LDAP_NO_LIMIT, &amp;result ) ) != LDAP_SUCCESS ) {<br>...<br></pre><br><br>Because base DN originates from user input and the query is performed under an anonymous bind, an attacker could alter the results of the query by specifying an unexpected <code>dn</code> string. The problem is that the developer failed to leverage the appropriate access control mechanisms necessary to restrict subsequent queries to access only employee records the current user is permitted to read.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 90</em> <br></p>
																									   <p>[8] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 116</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[14] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_log_forging</key>
    <internalKey>Input Validation and Representation/Log Forging</internalKey>
    <name>Log Forging</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Writing unvalidated user input to log files could allow an attacker to forge log entries or inject malicious content into the logs.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Log forging vulnerabilities occur when:<br><br>1. Data enters an application from an untrusted source.<br><br>2. The data written to an application or system log file.<br><br>Applications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending upon the nature of the application, log files can be reviewed manually as required, or culled automatically by tools that search the logs for important data points or trends.<br><br>Examination of the log files can be hindered or conclusions based on log data can be wrong if an attacker is allowed to supply data to the application that is subsequently logged verbatim. An attacker might insert false entries into the log file by including log entry separator characters in their data. If the log file is processed automatically, the attacker can render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker injects code or other commands into the log file and takes advantage of a vulnerability in the log processing utility [2].<br><br><b>Example:</b> The following code from a CGI script accepts a string submitted by the user and attempts to convert it into the long integer value it represents. If the value fails to parse as an integer, then its value is logged with an error message indicating what happened.<br><br><pre><br>long value = strtol(val, &amp;endPtr, 10);<br>if (*endPtr != '\0')<br>	syslog(LOG_INFO,"Illegal value = %s",val);<br>...<br><br></pre><br><br>If a user submits the string "<code>twenty-one</code>" for <code>val</code>, the following entry is logged:<br><br><pre><br>Illegal value=twenty-one<br></pre><br><br>However, if an attacker submits the string "<code>twenty-one\n\nINFO: User logged out=evil</code>", the following entry is logged:<br><br><pre><br>	INFO: Illegal value=twenty-one<br><br>	INFO: User logged out=evil<br></pre><br><br>Clearly, the attacker can use this same mechanism to insert arbitrary log entries. For this type of log forging attack to be effective, an attacker must first identify valid log entry formats, but this can often be accomplished by through system information leaks in the target application.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3690.2 CAT II, APP3690.4 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3690.2 CAT II, APP3690.4 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3690.2 CAT II, APP3690.4 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3690.2 CAT II, APP3690.4 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3690.2 CAT II, APP3690.4 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - FIPS200 - (FISMA) <em>AU, SI</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AU-9 Protection of Audit Information (P1)</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 117</em> <br></p>
																									   <p>[13] G. Hoglund, G. McGraw <em>Exploiting Software</em> Addison-Wesley<br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2, Requirement 10.5.2</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1, Requirement 10.5.2</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1, Requirement 10.5.2</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1, Requirement 10.5.2</em> <br></p>
																									   <p>[19] A. Muffet <em>The night the log was forged.</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_out_of_bounds_read</key>
    <internalKey>Input Validation and Representation/Out-of-Bounds Read</internalKey>
    <name>Out-of-Bounds Read</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program reads data from outside the bounds of allocated memory.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br><br>In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br><br>Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including heap buffer overflows and off-by-one errors among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3].<br><br>At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily exceed the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br><br>In this case, the program reads from outside the bounds of allocated memory, which can allow access to sensitive information, introduce incorrect behavior, or cause the program to crash.<br><br><b>Example 1:</b> In the following code, the call to <code>memcpy()</code> reads memory from outside the allocated bounds of <code>cArray</code>, which contains <code>MAX</code> elements of type <code>char</code>, while <code>iArray</code> contains <code>MAX</code> elements of type <code>int</code>.<br><br><pre><br>void MemFuncs() {<br>   char array1[MAX];<br>   int  array2[MAX];<br>   memcpy(array2, array1, sizeof(array2));<br>}<br></pre><br><br><b>Example 2:</b> The following short program uses an untrusted command line argument as the search buffer in a call to <code>memchr()</code> with a constant number of bytes to be analyzed.<br><br><pre><br>int main(int argc, char** argv) {<br>  char* ret = memchr(argv[0], 'x', MAX_PATH);<br>  printf("%s\n", ret);<br>}<br></pre><br><br>The program is meant to print a substring of <code>argv[0]</code>, by searching the <code>argv[0]</code> data up to a constant number of bytes. However, as the (constant) number of bytes might be larger than the data allocated for <code>argv[0]</code>, the search might go on beyond the data allocated for <code>argv[0]</code>. This will be the case when <code>x</code> is not found in <code>argv[0]</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[7] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 125, CWE ID 129, CWE ID 131, CWE ID 805</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 119</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 131</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 805, Risky Resource Management - CWE ID 129, Risky Resource Management - CWE ID 131</em> <br></p>
																									   <p>[17] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>
																									   <p>[18] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_out_of_bounds_read_off_by_one</key>
    <internalKey>Input Validation and Representation/Out-of-Bounds Read/Off-by-One</internalKey>
    <name>Out-of-Bounds Read: Off-by-One</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program reads data from just outside the bounds of allocated memory.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br><br>In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br><br>Although this type of off-by-one error is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including stack and heap buffer overflows among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3].<br><br>At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily exceed the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br><br>In this case, the program reads from outside the bounds of allocated memory, which can allow access to sensitive information, introduce incorrect behavior, or cause the program to crash.<br><br><b>Example:</b> The following code sequentially dereferences five-element array of <code>char</code>, with the last reference introducing an off-by-one error.<br><br><pre><br>char Read() {<br><br>char buf[5];<br>return 0<br>        + buf[0]<br>        + buf[1]<br>        + buf[2]<br>        + buf[3]<br>        + buf[4]<br>        + buf[5];<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[7] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 125, CWE ID 129, CWE ID 131, CWE ID 193, CWE ID 805</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 119, Risky Resource Management - CWE ID 682</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 131</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 805, Risky Resource Management - CWE ID 129, Risky Resource Management - CWE ID 131</em> <br></p>
																									   <p>[17] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>
																									   <p>[18] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_out_of_bounds_read_signed_comparison</key>
    <internalKey>Input Validation and Representation/Out-of-Bounds Read/Signed Comparison</internalKey>
    <name>Out-of-Bounds Read: Signed Comparison</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program uses a signed comparison to check a value that is later treated as unsigned. This could lead the program to read data from outside the bounds of allocated memory.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br><br>In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br><br>Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including heap buffer overflows and off-by-one errors among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3].<br><br>At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily exceed the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br><br>In this case, the program reads from outside the bounds of allocated memory, which can allow access to sensitive information, introduce incorrect behavior, or cause the program to crash.<br><br><b>Example:</b> The following code attempts to prevent an out-of-bounds read buffer overflow by checking that the untrusted value read from <code>getInputLength()</code> is less than the size of the destination buffer <code>output</code>. However, because the comparison between <code>len</code> and <code>MAX</code> is signed, if <code>len</code> is negative, it will be become a very large positive number when it is converted to an unsigned argument to <code>memcpy()</code>.<br><br><pre><br>void TypeConvert() {<br>   char input[MAX];<br>   char output[MAX];<br><br>   fillBuffer(input);<br>   int len = getInputLength();<br><br>   if (len &lt;= MAX) {<br>      memcpy(output, input, len);<br>   }<br>   ...<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3550 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3550 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3550 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3550 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3550 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[7] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 195, CWE ID 805</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 805</em> <br></p>
																									   <p>[15] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>
																									   <p>[16] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_path_manipulation</key>
    <internalKey>Input Validation and Representation/Path Manipulation</internalKey>
    <name>Path Manipulation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Allowing user input to control paths used in filesystem operations could enable an attacker to access or modify otherwise protected system resources.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Path manipulation errors occur when the following two conditions are met:<br><br>1. An attacker can specify a path used in an operation on the filesystem.<br><br>2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.<br><br>For example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.<br><br><IfDef var="ConditionalDescriptions"><br> <br></IfDef><br><br><b>Example 1:</b> The following code uses input from a CGI request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as "<code>../../apache/conf/httpd.conf</code>", which will cause the application to delete the specified configuration file.<br><br><pre><br>char* rName = getenv("reportName");<br>...<br>unlink(rName);<br></pre><br><br><b>Example 2:</b> The following code uses input from the command line to determine which file to open and echo back to the user. If the program runs with privileges and malicious users can create soft links to the file, they can use the program to read the first part of any file on the system.<br><br><pre><br>ifstream ifs(argv[0]);<br>string s;<br>ifs &gt;&gt; s;<br>cout &lt;&lt; s;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 22, CWE ID 73</em> <br></p>
																									   <p>[11] G. Hoglund, G. McGraw <em>Exploiting Software</em> Addison-Wesley<br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Path Traversal</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[18] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 022</em> <br></p>
																									   <p>[19] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 022</em> <br></p>
																									   <p>[20] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 426</em> <br></p>
																									   <p>[21] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[22] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_process_control</key>
    <internalKey>Input Validation and Representation/Process Control</internalKey>
    <name>Process Control</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Loading a library without specifying an absolute path can result in the program using a malicious library supplied by an attacker. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Process control vulnerabilities take two forms:<br><br>- An attacker can change the name of the library that the program executes: the attacker explicitly controls what the library name is.<br><br>- An attacker can change the environment in which the library is loaded: the attacker implicitly controls what the library name means.<br><br>In this case we are primarily concerned with the second scenario, the possibility that an attacker may be able to control the environment in such a way that the program loads a malicious version of the named library.<br><br>Process control vulnerabilities of this type occur when:<br><br>1. An attacker provides a malicious library to an application.<br><br>2. The application loads the malicious library because it fails to specify an absolute path or verify the file being loaded.<br><br>3. By executing code from the library, the application gives the attacker a privilege or capability that the attacker would not otherwise have.<br><br><b>Example:</b> The following code is from a web-based administration utility that allows users access to an interface through which they can update their profile on the system. The utility makes use of a library named <code>liberty.dll</code>, which is normally found in a standard system directory.<br><br><pre><br>LoadLibrary("liberty.dll");<br></pre><br><br>The problem is that the program does not specify an absolute path for <code>liberty.dll</code>. If an attacker is able to place a malicious library named <code>liberty.dll</code> higher in the search order than file the application intends to load, then the application will load the malicious copy instead of the intended file. Because of the nature of the application, it runs with elevated privileges, which means the contents of the attacker's <code>liberty.dll</code> will now be run with elevated privileges, possibly giving the attacker complete control of the system.<br><br>The type of attack seen in this example is made possible because of the search order used by <code>LoadLibrary()</code> when an absolute path is not specified. If the current directory is searched before system directories, as was the case up until the most recent versions of Windows, then this type of attack becomes trivial if the attacker can execute the program locally. The search order is operating system version dependent, and is controlled on newer operating systems by the value of the registry key:<br><br><pre><br>HKLM\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode<br></pre><br><br>This key is not defined on Windows 2000/NT and Windows Me/98/95 systems.<br><br>On systems where the key does exist, <code>LoadLibrary()</code> behaves as follows:<br><br>If <code>SafeDllSearchMode</code> is 1, the search order is as follows:<br>(Default setting for Windows XP-SP1 and later, as well as Windows Server 2003.)<br>1. The directory from which the application was loaded.<br>2. The system directory.<br>3. The 16-bit system directory, if it exists.<br>4. The Windows directory.<br>5. <b>The current directory.</b><br>6. The directories that are listed in the <code>PATH</code> environment variable.<br><br>If <code>SafeDllSearchMode</code> is 0, the search order is as follows:<br>1. The directory from which the application was loaded.<br>2. <b>The current directory.</b><br>3. The system directory.<br>4. The 16-bit system directory, if it exists.<br>5. The Windows directory.<br>6. The directories that are listed in the <code>PATH</code> environment variable.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 114</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.4</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_resource_injection</key>
    <internalKey>Input Validation and Representation/Resource Injection</internalKey>
    <name>Resource Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Allowing user input to control resource identifiers could enable an attacker to access or modify otherwise protected system resources.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  A resource injection issue occurs when the following two conditions are met:<br><br>1. An attacker can specify the identifier used to access a system resource.<br><br>For example, an attacker may be able to specify a port number to be used to connect to a network resource.<br><br>2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.<br><br>For example, the program may give the attacker the ability to transmit sensitive information to a third-party server.<br><br>Note: Resource injection that involves resources stored on the filesystem goes by the name path manipulation and is reported in separate category. See the path manipulation description for further details of this vulnerability.<br><br><b>Example:</b> The following code uses a port number read from a CGI request to create a socket.<br><br><pre><br>...<br>char* rPort = getenv("rPort");<br>...<br>serv_addr.sin_port = htons(atoi(rPort));<br>if (connect(sockfd,&amp;serv_addr,sizeof(serv_addr)) &lt; 0)<br>error("ERROR connecting");<br>...<br></pre><br><br>The kind of resource affected by user input indicates the kind of content that may be dangerous.  For example, data containing special characters like period, slash, and backslash are risky when used in methods that interact with the file system. Similarly, data that contains URLs and URIs is risky for functions that create remote connections.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 99</em> <br></p>
																									   <p>[11] G. Hoglund, G. McGraw <em>Exploiting Software</em> Addison-Wesley<br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.4</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[17] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_sql_injection</key>
    <internalKey>Input Validation and Representation/SQL Injection</internalKey>
    <name>SQL Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Constructing a dynamic SQL statement with input coming from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  SQL injection errors occur when:<br><br>1. Data enters a program from an untrusted source.<br><br>In this case HP Fortify Static Code Analyzer could not determine that the source of the data is trusted.<br><br>2. The data is used to dynamically construct a SQL query.<br><br><b>Example 1:</b> The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently authenticated user.<br><br><pre><br>...<br>ctx.getAuthUserName(&amp;userName); {<br>CString query = "SELECT * FROM items WHERE owner = '"<br>				 + userName + "' AND itemname = '"<br>				 + request.Lookup("item") + "'";<br>dbms.ExecuteSQL(query);<br>...<br></pre><br><br><b>Example 2:</b> Alternatively, a similar result could be obtained with SQLite using the following code:<br><br><pre><br>...<br>sprintf (sql, "SELECT * FROM items WHERE owner='%s' AND itemname='%s'", username, request.Lookup("item"));<br>printf("SQL to execute is: \n\t\t %s\n", sql);<br>rc = sqlite3_exec(db,sql, NULL,0, &amp;err);<br>...<br></pre><br><br>The query that this code intends to execute follows:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = &lt;userName&gt;<br>	AND itemname = &lt;itemName&gt;;<br></pre><br><br>However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>itemName</code> does not contain a single-quote character. If an attacker with the user name <code>wiley</code> enters the string "<code>name' OR 'a'='a</code>" for <code>itemName</code>, then the query becomes the following:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = 'wiley'<br>	AND itemname = 'name' OR 'a'='a';<br></pre><br><br>The addition of the <code>OR 'a'='a'</code> condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:<br><br><pre><br>	SELECT * FROM items;<br></pre><br><br>This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the <code>items</code> table, regardless of their specified owner.<br><br><b>Example 3:</b> This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name <code>wiley</code> enters the string "<code>name'); DELETE FROM items; --</code>" for <code>itemName</code>, then the query becomes the following two queries:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = 'wiley'<br>	AND itemname = 'name';<br><br>	DELETE FROM items;<br><br>	--'<br></pre><br><br>Many database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.<br><br>Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string "<code>name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a</code>", the following three valid statements will be created:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = 'wiley'<br>	AND itemname = 'name';<br><br>	DELETE FROM items;<br><br>	SELECT * FROM items WHERE 'a'='a';<br></pre><br><br>One traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:<br><br>- Target fields that are not quoted.<br><br>- Find ways to bypass the need for certain escaped meta-characters.<br><br>- Use stored procedures to hide the injected meta-characters..<br><br>Manually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks.<br><br>Another solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 89</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[15]  <em>ODBC API Reference: SQLBindParameters()</em> Microsoft<br></p>
																									   <p>[16]  <em>ODBC API Reference: SQLNumParams()</em> Microsoft<br></p>
																									   <p>[17]  <em>OLE DB Reference: ICommandWithParameters</em> Microsoft<br></p>
																									   <p>[18]  <em>Parameterized CRecordset and CDatabase for SQL Server</em> <br></p>
																									   <p>[19]  <em>Parameterizing a Recordset</em> Microsoft<br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[22] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[23] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[24] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[25] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[26] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>SQL Injection</em> <br></p>
																									   <p>[27] P. Finnigan <em>SQL Injection and Oracle, Part One</em> Security Focus<br></p>
																									   <p>[28] S. J. Friedl <em>SQL Injection Attacks by Example</em> <br></p>
																									   <p>[29] P. Litwin <em>Stop SQL Injection Attacks Before They Stop You</em> MSDN Magazine<br></p>
																									   <p>[30] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_setting_manipulation</key>
    <internalKey>Input Validation and Representation/Setting Manipulation</internalKey>
    <name>Setting Manipulation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Allowing external control of system settings can disrupt service or cause an application to behave in unexpected ways.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Setting manipulation vulnerabilities occur when an attacker can control values that govern the behavior of the system, manage specific resources, or in some way affect the functionality of the application.<br><br>Because setting manipulation covers a diverse set of functions, any attempt at illustrating it will inevitably be incomplete. Rather than searching for a tight-knit relationship between the functions addressed in the setting manipulation category, take a step back and consider the sorts of system values that an attacker should not be allowed to control.<br><br><b>Example 1:</b> The following C code accepts a number as one of its command line parameters and sets it as the host ID of the current machine.<br><br><pre><br>...<br>sethostid(argv[1]);<br>...<br></pre><br><br>Although a process must be privileged to successfully invoke <code>sethostid()</code>, unprivileged users may be able to invoke the program. The code in this example allows user input to directly control the value of a  system setting. If an attacker provides a malicious value for host ID, the attacker can misidentify the affected machine on the network or cause other unintended behavior.<br><br>In general, do not allow user-provided or otherwise untrusted data to control sensitive values.  The leverage that an attacker gains by controlling these values is not always immediately obvious, but do not underestimate the creativity of your attacker.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 15</em> <br></p>
																									   <p>[8] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[12] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_string_termination_error</key>
    <internalKey>Input Validation and Representation/String Termination Error</internalKey>
    <name>String Termination Error</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Relying on proper string termination could result in a buffer overflow. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  String termination errors occur when:<br><br>1. Data enters a program via a function that does not null terminate its output.<br><br>2. The data is passed to a function that requires its input to be null terminated.<br><br><b>Example 1:</b> The following code reads from <code>cfgfile</code> and copies the input into <code>inputbuf</code> using <code>strcpy()</code>.  The code mistakenly assumes that <code>inputbuf</code> will always contain a null terminator.<br><br><pre><br>#define MAXLEN 1024<br>...<br>char *pathbuf[MAXLEN];<br>...<br>read(cfgfile,inputbuf,MAXLEN); //does not null terminate<br>strcpy(pathbuf,inputbuf); //requires null terminated input<br>...<br></pre><br><br>The code in Example 1 will behave correctly if the data read from <code>cfgfile</code> is null terminated on disk as expected. But if an attacker is able to modify this input so that it does not contain the expected null character, the call to <code>strcpy()</code> will continue copying from memory until it encounters an arbitrary null character. This will likely overflow the destination buffer and, if the attacker can control the contents of memory immediately following <code>inputbuf</code>, can leave the application susceptible to a buffer overflow attack.<br><br><b>Example 2:</b> In the following code, <code>readlink()</code> expands the name of a symbolic link stored in the buffer <code>path</code>  so that the buffer <code>buf</code> contains the absolute path of the file referenced by the symbolic link. The length of the resulting value is then calculated using <code>strlen()</code>.<br><br><pre><br>...<br>char buf[MAXPATH];<br>...<br>readlink(path, buf, MAXPATH);<br>int length = strlen(buf);<br>...<br></pre><br><br>The code in Example 2 will not behave correctly because the value read into <code>buf</code> by <code>readlink()</code> will not be null terminated. In testing, vulnerabilities like this one might not be caught because the unused contents of <code>buf</code> and the memory immediately following it may be null, thereby causing <code>strlen()</code> to appear as if it is behaving correctly. However, in the wild <code>strlen()</code> will continue traversing memory until it encounters an arbitrary null character on the stack, which results in a value of <code>length</code> that is much larger than the size of <code>buf</code> and may cause a buffer overflow in subsequent uses of this value.<br><br>Traditionally, strings are represented as a region of memory containing data terminated with a null character. Older string-handling methods frequently rely on this null character to determine the length of the string. If a buffer that does not contain a null terminator is passed to one of these functions, the function will read past the end of the buffer.<br><br>Malicious users typically exploit this type of vulnerability by injecting data with unexpected size or content into the application. They may provide the malicious input either directly as input to the program or indirectly by modifying application resources, such as configuration files. In the event that an attacker causes the application to read beyond the bounds of a buffer, the attacker may be able to use a resulting buffer overflow to inject and execute arbitrary code on the system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Buffer Overflow</em> <br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 170</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 665</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 665</em> <br></p>
																									   <p>[15] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[16] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_string_termination_error_truncate</key>
    <internalKey>Input Validation and Representation/String Termination Error(truncate)</internalKey>
    <name>String Termination Error(truncate)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program relies on proper string termination, but an intermediate function might have caused the source buffer to become unterminated. This could result in a buffer overflow.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  String termination errors caused by truncation occur when:<br><br>1. Data enters a program.<br><br>2. The data passes through a function that truncates it, removing the null terminator.<br><br>3. The data is passed to a function that requires its input to be null terminated.<br><br><b>Example 1:</b> The following code retrieves the value of a null-terminated environment variable and uses <code>strncpy()</code> to copy the data into <code>new</code> .  Later, the program incorrectly assumes <code>new</code> will always be null terminated when it is passed to <code>setenv()</code>.<br><br><pre><br>...<br>char *value = getenv("PWD");<br>...<br>char *new_value = strncpy(new, value, strlen(value));<br>setenv("PATH", new, 1);<br>...<br></pre><br><br>Because the call to <code>strncpy()</code> is bounded by the length of the string as computed by <code>strlen()</code>, which does not account for the null terminator, <code>new</code> will become unterminated and cause the call to <code>setenv()</code> to behave incorrectly. The function <code>setenv()</code> will continue copying from the memory following <code>new</code> until it encounters an arbitrary null character. If the function does not find a null terminator before reaching the maximum size of the program's environment, the behavior of the function and other environment functions is undefined. Even if an arbitrary null character is found, the <code>PATH</code> environment variable might be left pointing to invalid directories. Worse yet, if the attacker can control values in memory that follow <code>new</code>, then they might introduce malicious entries to <code>PATH</code>, thereby changing the meaning of commands executed subsequently.<br><br><b>Example 2:</b> In the following code, <code>fgets()</code> retrieves data from a stream and stores it in <code>buf</code>. The function guarantees that the data will not exceed the buffer size and that the result is null terminated. Later, <code>strncpy()</code> is used to copy a subset of the data to a new buffer, <code>data</code>. The length of the resulting value is then calculated using <code>strlen()</code>.<br><br><pre>...<br>char buf[MAXLEN];<br>fgets(buf, MAXLEN, stream);<br>...<br>strncpy(data, buf, data_size);<br>...<br>int length = strlen(data);<br>...<br></pre><br><br>The code in Example 2 will behave incorrectly if <code>data_size</code> is less than or equal to the length of data read from the stream because the null terminator will not be copied to <code>data</code>. In testing, vulnerabilities like this one might not be caught because the memory immediately following <code>data</code> will often be null, thereby causing <code>strlen()</code> to produce the correct answer accidentally. However, in practice, <code>strlen()</code> will continue traversing memory until it encounters an arbitrary null character on the stack, which can result in a value of <code>length</code> that is much larger than the size of <code>buf</code>. Subsequent operations on <code>data</code> that rely on <code>length</code>  might result in buffer overflow.<br><br>Traditionally, strings are represented as a region of memory containing data terminated with a null character. Older string-handling methods frequently rely on this null character to determine the length of the string. If a string is truncated by a function that does not guarantee null termination, the length function will read past the end of the buffer.<br>Malicious users could exploit this type of vulnerability by injecting data with an unexpectedly large size into the application. They may provide the malicious input either directly as input to the program or indirectly by modifying application resources, such as configuration files. In the event that an attacker causes the application to read beyond the bounds of a buffer, the attacker may be able to use a resulting buffer overflow to inject and execute arbitrary code on the system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Buffer Overflow</em> <br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 170</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 665</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 665</em> <br></p>
																									   <p>[15] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[16] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_unsafe_reflection</key>
    <internalKey>Input Validation and Representation/Unsafe Reflection</internalKey>
    <name>Unsafe Reflection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An attacker may be able to create unexpected control flow paths through the application, potentially bypassing security checks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner.<br><br>This situation becomes a doomsday scenario if the attacker can upload files into a location that appears on the application's path or library path. Under either of these conditions, the attacker can use reflection to introduce new, presumably malicious, behavior into the application.<br><br><b>Example:</b> A common reason that programmers use the reflection API is to implement their own command dispatcher. The following example shows a JNI command dispatcher that uses reflection to execute a Java method identified by a value read from a CGI request. This implementation allows an attacker to call any function defined in <code>clazz</code>.<br><br><pre><br>char* ctl = getenv("ctl");<br>...<br>jmethodID mid = GetMethodID(clazz, ctl, sig);<br>status = CallIntMethod(env, clazz, mid, JAVA_ARGS);<br>...<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 470</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.4</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_xml_external_entity_injection</key>
    <internalKey>Input Validation and Representation/XML External Entity Injection</internalKey>
    <name>XML External Entity Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The identified method allows external entity references. This call could allow an attacker to inject an xml external entity into the XML document to reveal the contents of files or internal network resources.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  XML external entity injection occurs when:<br><br>1. Data enters a program from an untrusted source.<br><br>2. The data is written to an &lt;ENTITY&gt; element of the DTD (Document Type Definition) in an XML document.<br><br>Applications typically use XML to store data or send messages. When used to store data, XML documents are often treated like databases and can potentially contain sensitive information. XML messages are often used in web services and can also be used to transmit sensitive information. XML message can even be used to send authentication credentials.<br><br>The semantics of XML documents and messages can be altered if an attacker has the ability to write raw XML. In the most benign case, an attacker may be able to insert nested entity references and cause an XML parser consume ever increasing amounts of CPU resources. In more nefarious cases of XML external entity injection (XXE), an attacker may be able to add XML elements that expose the contents of local file system resources or reveal the existence of internal network resources.<br><br><b>Example 1:</b>Here is some Objective-C code that is vulnerable to XXE attacks:<br><br><pre><br>- (void) parseSomeXML: (NSString *) rawXml {<br><br>    BOOL success;<br>    NSData *rawXmlConvToData = [rawXml dataUsingEncoding:NSUTF8StringEncoding];<br>    NSXMLParser *myParser = [[NSXMLParser alloc] initWithData:rawXmlConvToData];<br>    [myParser setShouldResolveExternalEntities:YES];<br>    [myParser setDelegate:self];<br>}<br></pre><br><br>Assume an attacker is able to control rawXml such that the xml looks like the following:<br><br><pre><br> &lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br> &lt;!DOCTYPE foo [<br>   &lt;!ELEMENT foo ANY &gt;<br>   &lt;!ENTITY xxe SYSTEM "file:///c:/boot.ini" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;<br></pre><br><br>When the XML is evaluated by the server, the &lt;foo&gt; element will contain the contents of the boot.ini file.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3810 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3810 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3810 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3810 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 611</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_xml_injection</key>
    <internalKey>Input Validation and Representation/XML Injection</internalKey>
    <name>XML Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The identified method writes XML unvalidated input. This call could allow an attacker to inject arbitrary elements or attributes into the XML document.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  XML injection occurs when:<br><br>1. Data enters a program from an untrusted source.<br><br><IfDef var="ConditionalDescriptions"><br> <br></IfDef><br><br>2. The data is written to an XML document.<br><br>Applications typically use XML to store data or send messages. When used to store data, XML documents are often treated like databases and can potentially contain sensitive information. XML messages are often used in web services and can also be used to transmit sensitive information. XML message can even be used to send authentication credentials.<br><br>The semantics of XML documents and messages can be altered if an attacker has the ability to write raw XML. In the most benign case, an attacker may be able to insert extraneous tags and cause an XML parser to throw an exception. In more nefarious cases of XML injection, an attacker may be able to add XML elements that change authentication credentials or modify prices in an XML e-commerce database. In some cases, XML injection can lead to cross-site scripting or dynamic code evaluation.<br><br><b>Example 1:</b><br><br>Assume an attacker is able to control <code>shoes</code> in following XML.<br><pre><br>&lt;order&gt;<br>   &lt;price&gt;100.00&lt;/price&gt;<br>   &lt;item&gt;shoes&lt;/item&gt;<br>&lt;/order&gt;<br></pre><br><br>Now imagine this XML is included in a back end web service request to place an order for a pair of shoes. Suppose the attacker modifies his request and replaces <code>shoes</code> with <code>shoes&lt;/item&gt;&lt;price&gt;1.00&lt;/price&gt;&lt;item&gt;shoes</code>. The new XML would look like:<pre><br>&lt;order&gt;   &lt;price&gt;100.00&lt;/price&gt;   &lt;item&gt;shoes&lt;/item&gt;&lt;price&gt;1.00&lt;/price&gt;&lt;item&gt;shoes&lt;/item&gt;&lt;/order&gt;<br></pre><br><br>When using SAX parsers, the value from the second <code>&lt;price&gt;</code> overrides the value from the first <code>&lt;price&gt;</code> tag. This allows the attacker to purchase a pair of $100 shoes for $1.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3810 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3810 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3810 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3810 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 91</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_xpath_injection</key>
    <internalKey>Input Validation and Representation/XPath Injection</internalKey>
    <name>XPath Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The identified method invokes an XPath query built using unvalidated input. This call could allow an attacker to modify the statement's meaning or to execute arbitrary XPath queries.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  XPath injection occurs when:<br><br>1.      Data enters a program from an untrusted source.<br><br><br><IfDef var="ConditionalDescriptions"><br> <br></IfDef><br><br>2.      The data used to dynamically construct an XPath query.<br><br><br><br><b>Example 1:</b> The following Objective-C code, which calls C APIs, dynamically constructs and executes an XPath query that retrieves an e-mail address for a given account ID. The account ID is read from an HTTP request, and is therefore untrusted.<br><br><pre><br>...<br>    NSString *accountStr = account.text;<br><br>    xmlXPathContextPtr xpathCtx;<br>    NSString *query = @"/accounts/account[actId='" + accountStr + @"']/email/text()";<br><br>    xpathCtx = xmlXPathNewContext(doc);<br><br>    /* Evaluate XPath expression */<br>    xmlChar *queryString =<br>        (xmlChar *)[query cStringUsingEncoding:NSUTF8StringEncoding];<br>    xpathObj = xmlXPathEvalExpression(queryString, xpathCtx);<br>...<br></pre><br><br>Under normal conditions, such as searching for an e-mail address that belongs to the account number 1, the query that this code executes will look like the following:<br><br><code>/accounts/account[acctID='1']/email/text()</code><br><br>However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>acctID</code> does not contain a single-quote character. If an attacker enters the string <code>1' or '1' = '1</code> for <code>acctID</code>, then the query becomes the following:<br><br><code>/accounts/account[acctID='1' or '1' = '1']/email/text()</code><br><br>The addition of the <code>1' or '1' = '1</code> condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:<br><br><code>//email/text()</code><br><br>This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all e-mail addresses stored in the document, regardless of their specified owner.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 643</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[18] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>XPath Injection</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>security_features_access_control_anonymous_ldap_bind</key>
    <internalKey>Security Features/Access Control/Anonymous LDAP Bind</internalKey>
    <name>Access Control: Anonymous LDAP Bind</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Without proper access control, executing an LDAP statement that contains a user-controlled value can allow an attacker to access unauthorized records.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Executing LDAP queries under an anonymous bind, effectively without authentication, can allow an attacker to abuse a poorly configured LDAP environment.<br><br><b>Example 1:</b> The following code uses <code>ldap_simple_bind_s()</code> to bind anonymously to an LDAP directory.<br><br><pre><br>...<br>rc = ldap_simple_bind_s( ld, NULL, NULL );<br>  if ( rc != LDAP_SUCCESS ) {<br>    ...<br>  }<br>...<br></pre><br><br>All LDAP queries executed against <code>ld</code> will be performed without authentication and access control. An attacker may be able to manipulate one of these queries in an unexpected way to gain access to records that would otherwise be protected by the directory's access control mechanism.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A10 Failure to Restrict URL Access</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A2 Broken Access Control</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A7 Missing Function Level Access Control</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A8 Failure to Restrict URL Access</em> <br></p>
																									   <p>[5] Standards Mapping - FIPS200 - (FISMA) <em>AC</em> <br></p>
																									   <p>[6] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3480.1 CAT II</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 285</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 863</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.10, Requirement 7.2</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.2, Requirement 7.2</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8, Requirement 7.2</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8, Requirement 7.2</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_access_control_database</key>
    <internalKey>Security Features/Access Control/Database</internalKey>
    <name>Access Control: Database</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Without proper access control, executing a SQL statement that contains a user-controlled primary key can allow an attacker to view unauthorized records.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Database access control errors occur when:<br><br>1.	Data enters a program from an untrusted source.<br><br><br>2.	The data is used to specify the value of a primary key in a SQL query.<br><br><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier [1]. The identifier is selected from a list of all invoices associated with the current authenticated user.<br><br><pre><br>...<br>CMyRecordset rs(&amp;dbms);<br>rs.PrepareSQL("SELECT * FROM invoices WHERE id = ?");<br>rs.SetParam_int(0,atoi(r.Lookup("invoiceID").c_str()));<br>rs.SafeExecuteSQL();<br>...<br></pre><br><br>The problem is that the developer has failed to consider all of the possible values of <code>id</code>. Although the interface generates a list of invoice identifiers that belong to the current user, an attacker can bypass this interface to request any desired invoice. Because the code in this example does not check to ensure that the user has permission to access the requested invoice, it will display any invoice, even if it does not belong to the current user.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A2 Broken Access Control</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - FIPS200 - (FISMA) <em>AC</em> <br></p>
																									   <p>[6] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 566</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 863</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[20] S. J. Friedl <em>SQL Injection Attacks by Example</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_access_control_ldap</key>
    <internalKey>Security Features/Access Control/LDAP</internalKey>
    <name>Access Control: LDAP</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Without proper access control, executing an LDAP statement that contains a user-controlled value can allow an attacker to access unauthorized directory entries.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Database access control errors occur when:<br><br>1.	Data enters a program from an untrusted source.<br><br>2.	The data is used to specify a data value in an LDAP query.<br><br><b>Example 1:</b> The following code uses a whitelist to validate an employee name read from a socket before using it to construct an LDAP query. This validation prevents LDAP injection vulnerabilities, but may still leave the code vulnerable.<br><br><pre><br>...<br>fgets(username, sizeof(username), socket);<br><br>char* regex = "^[a-zA-Z\-\.']$";<br>re = pcre_compile(regex, 0, &amp;err, &amp;errOffset, NULL);<br><br>rc = pcre_exec(re, NULL, username, strlen(username), 0, 0, NULL, 0);<br><br>if(rc == 1) {<br>  snprintf(filter, sizeof(filter), "(employee=%s)", username);<br>  if ( ( rc = ldap_search_ext_s( ld, FIND_DN, LDAP_SCOPE_BASE,<br>         filter, NULL, 0, NULL, NULL, LDAP_NO_LIMIT,<br>         LDAP_NO_LIMIT, &amp;result ) ) == LDAP_SUCCESS ) {<br>    ...<br>  }<br>}<br></pre><br><br>The problem is that the developer has failed to consider what would happen if an attacker provides alternate values of <code>username</code>. Because the code in this example executes the query under an anonymous bind, it will return the directory entry for any valid employee ID, regardless of the identity of the current authenticated user.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A2 Broken Access Control</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - FIPS200 - (FISMA) <em>AC</em> <br></p>
																									   <p>[6] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 639</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 863</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_insecure_randomness</key>
    <internalKey>Security Features/Insecure Randomness</internalKey>
    <name>Insecure Randomness</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Standard pseudo-random number generators cannot withstand cryptographic attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness in a security-sensitive context.<br><br>Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators (PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.<br><br>There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties, but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use in cases where security depends on generated values being unpredictable. Cryptographic PRNGs address this problem by generating output that is more difficult to predict. For a value to be cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish between it and a truly random value. In general, if a PRNG algorithm is not advertised as being cryptographically secure, it is probably a statistical PRNG and should not be used in security-sensitive contexts, where its use can lead to serious vulnerabilities such as easy-to-guess temporary passwords, predictable cryptographic keys, session hijacking, and DNS spoofing.<br><br><b>Example:</b> The following code uses a statistical PRNG to create a URL for a receipt that remains active for some period of time after a purchase.<br><br><pre><br>char* CreateReceiptURL() {<br>    int num;<br>    time_t t1;<br>    char *URL = (char*) malloc(MAX_URL);<br>    if (URL) {<br>        (void) time(&amp;t1);<br>        srand48((long) t1);     /* use time to set seed */<br>        sprintf(URL, "%s%d%s", "http://test.com/", lrand48(), ".html");<br>    }<br>    return URL;<br>}<br></pre><br><br>This code uses the <code>lrand48()</code> function to generate "unique" identifiers for the receipt pages it generates. Because <code>lrand48()</code> is a statistical PRNG, it is easy for an attacker to guess the strings it generates. Although the underlying design of the receipt system is also faulty, it would be more secure if it used a random number generator that did not produce predictable receipt identifiers.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em>.NET System.Security.Cryptography: Random Number Generation</em> Microsoft<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[10]  <em>BeeCrypt</em> <br></p>
																									   <p>[11] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[12]  <em>Crypt++</em> <br></p>
																									   <p>[13]  <em>CryptLib</em> <br></p>
																									   <p>[14]  <em>CryptoAPI: CryptGenRandom()</em> Microsoft<br></p>
																									   <p>[15] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 330</em> <br></p>
																									   <p>[16] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[17] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[18] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[19]  <em>OpenSSL</em> <br></p>
																									   <p>[20] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 330</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[22] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[23] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[24] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[25]  <em>RtlGenRandom()</em> Microsoft<br></p>
																									   <p>[26] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-13 Cryptographic Protection (P1)</em> <br></p>
																									   <p>[27] B. Schneier <em>Yarrow: A secure pseudorandom number generator</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_insecure_randomness_poor_seed</key>
    <internalKey>Security Features/Insecure Randomness/Poor Seed</internalKey>
    <name>Insecure Randomness: Poor Seed</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Functions which generate random or pseudo-random values, which are passed a seed, should not be called with a constant integer argument.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Functions which generate random or pseudo-random values, which are passed a seed, should not be called with a constant integer argument. If a pseudo-random number generator (such as <code>rand()</code>) is seeded with a specific value (using a function like <code>srand(unsigned int)</code>), the values returned by <code>rand()</code> and similar methods which return or assign values are predictable.<br><br><b>Example:</b> Below, the values produced by the pseudo random number generator are predictable in the first two blocks because both start with the same seed.<br><br><pre><br>        srand(2223333);<br>        float randomNum = (rand() % 100);<br>        syslog(LOG_INFO, "Random: %1.2f", randomNum);<br>        randomNum = (rand() % 100);<br>        syslog(LOG_INFO, "Random: %1.2f", randomNum);<br><br>        srand(2223333);<br>        float randomNum2 = (rand() % 100);<br>        syslog(LOG_INFO, "Random: %1.2f", randomNum2);<br>        randomNum2 = (rand() % 100);<br>        syslog(LOG_INFO, "Random: %1.2f", randomNum2);<br><br>        srand(1231234);<br>        float randomNum3 = (rand() % 100);<br>        syslog(LOG_INFO, "Random: %1.2f", randomNum3);<br>        randomNum3 = (rand() % 100);<br>        syslog(LOG_INFO, "Random: %1.2f", randomNum3);<br></pre><br><br>  In this example the results for randomNum1 and randomNum2 were identically seeded, so each call to <code>rand()</code> after the call which seeds the random number generator <code>srand(SEED_VALUE)</code>, will result in the same outputs in the same calling order.  For example, the output might resemble the following:<br><br><pre><br>Random: 32.00<br>Random: 73.00<br>Random: 32.00<br>Random: 73.00<br>Random: 15.00<br>Random: 75.00<br></pre><br><br>  These results are far from random.<br><br>    
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[9] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 330</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 330</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-13 Cryptographic Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_key_management_hardcoded_encryption_key</key>
    <internalKey>Security Features/Key Management/Hardcoded Encryption Key</internalKey>
    <name>Key Management: Hardcoded Encryption Key</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Encryption keys can compromise system security in a way that cannot be easily remedied.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is never a good idea to hardcode an encryption key. Not only does hardcoding an encryption key allow all of the project's developers to view the encryption key, it also makes fixing the problem extremely difficult. Once the code is in production, the encryption key cannot be changed without patching the software. If the account protected by the encryption key is compromised, the owners of the system will be forced to choose between security and availability.<br><br><br><b>Example:</b> The following code uses a hardcoded encryption key:<br><br><pre><br>...<br>char encryptionKey[] = "lakdsljkalkjlksdfkl";<br>...<br></pre><br><br>Anyone who has access to the code will have access to the encryption key. Once the program has shipped, there is no way to change the encryption key unless the program is patched. An employee with access to this information can use it to break into the system. Even worse, if attackers have access to the executable for the application they can disassemble the code, which will contain the value of the encryption key used.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 259, CWE ID 798</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12]  <em>iOS On-Disk Encryption</em> Apple<br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 259</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 798</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 798</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-12 Cryptographic Key Establishment and Management (P1)</em> <br></p>
																									   <p>[22]  <em>Windows Data Protection</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_least_privilege_violation</key>
    <internalKey>Security Features/Least Privilege Violation</internalKey>
    <name>Least Privilege Violation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The elevated privilege level required to perform operations such as <code>chroot()</code> should be dropped immediately after the operation is performed.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  When a program calls a privileged function, such as <code>chroot()</code>, it must first acquire <code>root</code> privilege. As soon as the privileged operation has completed, the program should drop <code>root</code> privilege and return to the privilege level of the invoking user.<br><br><b>Example:</b> The following code calls <code>chroot()</code> to restrict the application to a subset of the filesystem below <code>APP_HOME</code> in order to prevent an attacker from using the program to gain unauthorized access to files located elsewhere. The code then opens a file specified by the user and processes the contents of the file.<br><br><pre><br>...<br>chroot(APP_HOME);<br>chdir("/");<br><br>FILE* data = fopen(argv[1], "r+");<br>...<br></pre><br><br>Constraining the process inside the application's home directory before opening any files is a valuable security measure. However, the absence of a call to <code>setuid()</code> with some non-zero value means the application is continuing to operate with unnecessary <code>root</code> privileges. Any successful exploit carried out by an attacker against the application can now result in a privilege escalation attack because any malicious operations will be performed with the privileges of the superuser. If the application drops to the privilege level of a non-<code>root</code> user, the potential for damage is substantially reduced.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-6 Least Privilege (P1)</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3500 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3500 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3500 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3500 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3500 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 272</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 7.1.1</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 7.1.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 7.1.2</em> <br></p>
																									   <p>[13] A. Chuvakin <em>Using Chroot Securely</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management</key>
    <internalKey>Security Features/Password Management</internalKey>
    <name>Password Management</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Storing a password in plaintext could result in a system compromise.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Password management issues occur when a password is stored in plaintext in an application's configuration files or other data store.<br><br><b>Example:</b> The following code reads a password from the registry and uses the password to connect to a database.<br><br><pre><br>...<br>RegQueryValueEx(hkey,TEXT(.SQLPWD.),NULL,<br>                NULL,(LPBYTE)pwd, &amp;size);<br>rc = SQLConnect(*hdbc, server, SQL_NTS, uid,<br>                SQL_NTS, pwd, SQL_NTS);<br>...<br></pre><br><br>This code will run successfully, but anyone who has access to the registry key used to store the password can read the value of <code>pwd</code>. If a devious employee has access to this information, they can use it to break into the system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 256</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>
																									   <p>[18]  <em>Windows Data Protection</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management_empty_password</key>
    <internalKey>Security Features/Password Management/Empty Password</internalKey>
    <name>Password Management: Empty Password</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Empty passwords can compromise system security in a way that cannot be easily remedied.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is never a good idea to assign an empty string to a password variable. If the empty password is used to successfully authenticate against another system, then the corresponding account's security is likely compromised because it accepts an empty password. If the empty password is merely a placeholder until a legitimate value can be assigned to the variable, then it can confuse anyone unfamiliar with the code and potentially cause problems on unexpected control flow paths.<br><br><br><br><b>Example 1:</b> The code below attempts to connect to a database with an empty password.<br><pre><br>    ...<br>    rc = SQLConnect(*hdbc, server, SQL_NTS, "scott", SQL_NTS, "", SQL_NTS);<br>    ...<br></pre><br><br>If the code in Example 1 succeeds, it indicates that the database user account "scott" is configured with an empty password, which can be easily guessed by an attacker. Even worse, once the program has shipped, updating the account to use a non-empty password will require a code change.<br><br><b>Example 2:</b> The code below initializes a password variable to an empty string, attempts to read a stored value for the password, and compares it against a user-supplied value.<br><br><pre><br>    ...<br>    char *stored_password = "";<br><br>    readPassword(stored_password);<br><br>    if(safe_strcmp(stored_password, user_password))<br>        // Access protected resources<br>        ...<br>    }<br>    ...<br></pre><br><br>If <code>readPassword()</code> fails to retrieve the stored password due to a database error or another problem, then an attacker could trivially bypass the password check by providing an empty string for <code>user_password</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 259</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 259</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management_hardcoded_password</key>
    <internalKey>Security Features/Password Management/Hardcoded Password</internalKey>
    <name>Password Management: Hardcoded Password</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Hardcoded passwords can compromise system security in a way that cannot be easily remedied.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.<br><br><b>Example:</b> The following code uses a hardcoded password to connect to a database:<br><br><pre><br>...<br>rc = SQLConnect(*hdbc, server, SQL_NTS, "scott",<br>                SQL_NTS, "tiger", SQL_NTS);<br>...<br></pre><br><br>This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user "scott" with a password of "tiger" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the executable for the application they can disassemble the code, which will contain the values of the passwords used.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 259, CWE ID 798</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 259</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 798</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 798</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>
																									   <p>[21]  <em>Windows Data Protection</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management_null_password</key>
    <internalKey>Security Features/Password Management/Null Password</internalKey>
    <name>Password Management: Null Password</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Null passwords can compromise security.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Assigning null to password variables is a bad idea because it can allow attackers to bypass password verification or might indicate that resources are protected by an empty password.<br><br><br><br><b>Example:</b> The code below initializes a password variable to null, attempts to read a stored value for the password, and compares it against a user-supplied value.<br><br><pre><br>    ...<br>    char *stored_password = NULL;<br><br>    readPassword(stored_password);<br><br>    if(safe_strcmp(stored_password, user_password))<br>        // Access protected resources<br>        ...<br>    }<br>    ...<br></pre><br><br>If <code>readPassword()</code> fails to retrieve the stored password due to a database error or another problem, then an attacker could trivially bypass the password check by providing a null value for <code>user_password</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 259</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 259</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management_password_in_comment</key>
    <internalKey>Security Features/Password Management/Password in Comment</internalKey>
    <name>Password Management: Password in Comment</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Storing passwords or password details in plaintext anywhere in the system or system code can compromise system security in a way that cannot be easily remedied.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is never a good idea to hardcode a password. Storing password details within comments is equivalent to hardcoding passwords.  Not only does it allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password is now leaked to the outside world and cannot be protected or changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.<br><br><br><b>Example:</b> The following comment specifies the default password to connect to a database:<br><br><pre><br>...<br>// Default username for database connection is "scott"<br>// Default password for database connection is "tiger"<br>...<br></pre><br><br>This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user "scott" with a password of "tiger" unless the program is patched. A devious employee with access to this information can use it to break into the system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 615</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management_weak_cryptography</key>
    <internalKey>Security Features/Password Management/Weak Cryptography</internalKey>
    <name>Password Management: Weak Cryptography</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Obscuring a password with a trivial encoding does not protect the password.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Password management issues occur when a password is stored in plaintext in an application's configuration files or other data store. A programmer can attempt to remedy the password management problem by obscuring the password with an encoding function, such as base 64 encoding, but this effort does not adequately protect the password.<br><br><b>Example:</b> The following code reads a password from the registry, decodes it using a trivial encoding algorithm and uses the password to connect to a database.<br><br><pre><br>...<br>RegQueryValueEx(hkey, TEXT(.SQLPWD.), NULL,<br>                NULL, (LPBYTE)pwd64, &amp;size64);<br>Base64Decode(pwd64, size64, (BYTE*)pwd, &amp;size);<br>rc = SQLConnect(*hdbc, server, SQL_NTS, uid,<br>                SQL_NTS, pwd, SQL_NTS);<br>...<br></pre><br><br>This code will run successfully, but anyone who has access to the registry key used to store the password can read the value of <code>pwd64</code> and easily determine that the value has been base 64 encoded. If a devious employee has access to this information, they can use it to break into the system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 261</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>
																									   <p>[19]  <em>Windows Data Protection</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_privacy_violation</key>
    <internalKey>Security Features/Privacy Violation</internalKey>
    <name>Privacy Violation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Mishandling private information, such as customer passwords or social security numbers, can compromise user privacy and is often illegal. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Privacy violations occur when:<br><br>1. Private user information enters the program.<br><br>2. The data is written to an external location, such as the console, file system, or network.<br><br><b>Example:</b> The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the <code>get_password()</code> function returns the user-supplied plaintext password associated with the account.<br><br><pre><br>pass = get_password();<br>...<br>fprintf(dbms_log, "%d:%s:%s:%s", id, pass, type, tstamp);<br></pre><br><br>The code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for any and all data, it should not be trusted implicitly, particularly when privacy is a concern.<br><br>Private data can enter a program in a variety of ways:<br><br>- Directly from the user in the form of a password or personal information.<br><br>- Accessed from a database or other data store by the application.<br><br>- Indirectly from a partner or other third party.<br><br>Sometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates student identification based on student social security numbers, then the identification numbers should be considered private.<br><br>Security and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can create additional risk.<br><br>Although there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, it does not guarantee that the individuals who do have access can be trusted with certain data. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].<br><br>In response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:<br><br>- Safe Harbor Privacy Framework [3]<br><br>- Gramm-Leach Bliley Act (GLBA) [4]<br><br>- Health Insurance Portability and Accountability Act (HIPAA) [5]<br><br>- California SB-1386 [6]<br><br>Despite these regulations, privacy violations continue to occur with alarming frequency.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[3] J. Oates <em>AOL man pleads guilty to selling 92m email addies</em> The Register<br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3310 CAT I, APP3340 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[9]  <em>California SB-1386</em> Government of the State of California<br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 359</em> <br></p>
																									   <p>[11]  <em>Financial Privacy: The Gramm-Leach Bliley Act (GLBA)</em> Federal Trade Commission<br></p>
																									   <p>[12]  <em>Health Insurance Portability and Accountability Act (HIPAA)</em> U.S. Department of Human Services<br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[15]  <em>Privacy Initiatives</em> U.S. Federal Trade Commission<br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 6.5.5, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 6.5.6, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 8.2.1</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 8.4</em> <br></p>
																									   <p>[20]  <em>Safe Harbor Privacy Framework</em> U.S. Department of Commerce<br></p>
																									   <p>[21] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_weak_cryptographic_hash</key>
    <internalKey>Security Features/Weak Cryptographic Hash</internalKey>
    <name>Weak Cryptographic Hash</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  MD5 and SHA-1 are popular cryptographic hash algorithms often used to verify the integrity of messages and other data. Recent advances in cryptanalysis have discovered weaknesses in both algorithms. Consequently, MD5 and SHA-1 should no longer be relied upon to verify the authenticity of data in security-critical contexts.<br><br>Techniques for breaking MD5 hashes are advanced and widely available enough that the algorithm must not be relied upon for security. In the case of SHA-1, current techniques still require a significant amount of computational power and are more difficult to implement. However, attackers have found the Achilles' heel for the algorithm, and techniques for breaking it will likely lead to the discovery of even faster attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 310</em> <br></p>
																									   <p>[11] Xiaoyun Wang, Yiqun Lisa Yin, and Hongbo Yu <em>Finding Collisions in the Full SHA-1</em> <br></p>
																									   <p>[12] Xiaoyun Wang and Hongbo Yu <em>How to Break MD5 and Other Hash Functions</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[15] Stach & Liu <em>MD5 and MD4 Collision Generators</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-13 Cryptographic Protection (P1)</em> <br></p>
																									   <p>[22]  <em>SDL Development Practices</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_weak_cryptographic_hash_hardcoded_salt</key>
    <internalKey>Security Features/Weak Cryptographic Hash/Hardcoded Salt</internalKey>
    <name>Weak Cryptographic Hash: Hardcoded Salt</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  A hardcoded salt can compromise system security in a way that cannot be easily remedied.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is never a good idea to hardcode a salt. Not only does a hardcoded salt allow all of the project's developers to view the salt, it also makes fixing the problem extremely difficult. Once the code is in production, the salt cannot be easily changed. If attackers know the value of the salt, they can compute rainbow tables for the application and more easily reverse hashed values.<br><br><br><b>Example 1:</b> The following code uses a hardcoded salt:<br><pre><br>    ...<br>    crypt(password, &quot;ms&quot;);<br>    ...<br></pre><br><br>This code will run successfully, but anyone who has access to it will have access to the salt. Once the program has shipped, there is no going back from the salt "ms". A devious employee with access to this information can use it to break into the system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 326</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 759</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-13 Cryptographic Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_weak_encryption</key>
    <internalKey>Security Features/Weak Encryption</internalKey>
    <name>Weak Encryption</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Antiquated encryption algorithms such as DES no longer provide sufficient protection for use with sensitive data. Encryption algorithms rely on key size as one of the primary mechanism to ensure cryptographic strength. Cryptographic strength is often measured by the time and computational power needed to generate a valid key. Advances in computing power have made it possible to obtain small encryption keys in a reasonable amount of time. For example, the 56-bit key used in DES posed a significant computational hurdle in the 1970's when the algorithm was first developed, but today DES can be cracked in less than a day using commonly available equipment.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 327</em> <br></p>
																									   <p>[11] distributed.net <em>DES</em> <br></p>
																									   <p>[12]  <em>EVP_EncryptInit(3)</em> The OpenSSL Project<br></p>
																									   <p>[13]  <em>FAQ About the Electronic Frontier Foundation's "DES Cracker" Machine</em> Electronic Frontier Foundation<br></p>
																									   <p>[14] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[16]  <em>Microsoft Security Fundamentals</em> Microsoft<br></p>
																									   <p>[17] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[18] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 327</em> <br></p>
																									   <p>[19] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 327</em> <br></p>
																									   <p>[20] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 327</em> <br></p>
																									   <p>[21] John Kelsey, Bruce Schneier, and David Wagner <em>Related-key cryptanalysis of 3-WAY, Biham-DES, CAST, DES-X, NewDES, RC2, and TEA</em> <br></p>
																									   <p>[22] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[23] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[24] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[25] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[26] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-13 Cryptographic Protection (P1)</em> <br></p>
																									   <p>[27]  <em>SDL Development Practices</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_weak_encryption_inadequate_rsa_padding</key>
    <internalKey>Security Features/Weak Encryption/Inadequate RSA Padding</internalKey>
    <name>Weak Encryption: Inadequate RSA Padding</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The RSA algorithm is used without OAEP padding, thereby making the encryption weak.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  When used in practice, RSA is generally combined with some padding scheme. The goal of the padding scheme is to prevent a number of attacks that potentially work against RSA without padding.<br><br><b>Example 1:</b> The following code uses RSA encryption algorithm without appropriate padding.<br><pre><br>  void encrypt_with_rsa(BIGNUM *out, BIGNUM *in, RSA *key) {<br>    u_char *inbuf, *outbuf;<br>    int ilen;<br>    ...<br>    ilen = BN_num_bytes(in);<br>    inbuf = xmalloc(ilen);<br>    BN_bn2bin(in, inbuf);<br>    if ((len = RSA_public_encrypt(ilen, inbuf, outbuf, key, RSA_NO_PADDING)) &lt;= 0) {<br>      fatal(&quot;encrypt_with_rsa() failed&quot;);<br>    }<br>    ...<br>  }<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 325</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[14]  <em>OPENSSL Documentation</em> <br></p>
																									   <p>[15]  <em>PKCS #1 v2.1: RSA Cryptography Standard</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-13 Cryptographic Protection (P1)</em> <br></p>
																									   <p>[21]  <em>Wikipedia</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_weak_encryption_insufficient_key_size</key>
    <internalKey>Security Features/Weak Encryption/Insufficient Key Size</internalKey>
    <name>Weak Encryption: Insufficient Key Size</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An otherwise strong encryption algorithm is vulnerable to brute force attack when a small key size is used.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Current cryptography guidelines suggest that key lengths of at least 1024 bits should be used with the RSA algorithm. However, increased computing power and advances in factoring techniques[1] are challenging the security of 1024 bit RSA encryption.<br><br><b>Example 1:</b> The following code generates a 512 bit RSA encryption key.<br><pre><br>  EVP_PKEY * get_RSA_key() {<br>    unsigned long err;<br>    EVP_PKEY * pkey;<br>    RSA * rsa;<br>    rsa = RSA_generate_key(512, 35, NULL, NULL);<br>    if (rsa == NULL) {<br>      err = ERR_get_error();<br>      printf("Error = %s\n",ERR_reason_error_string(err));<br>      return NULL;<br>    }<br>    pkey = EVP_PKEY_new();<br>    EVP_PKEY_assign_RSA(pkey, rsa);<br>    return pkey;<br>  }<br></pre><br><br>When it comes to symmetric encryption, the key lengths should be at least 128 bits.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] J. Cheng <em>307-digit key crack endangers 1024-bit RSA</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[11]  <em>B. Chess and J. West, Secure Programming with Static Analysis. Boston, MA: Addison-Wesley, 2007.</em> <br></p>
																									   <p>[12]  <em>Cryptographic Algorithms and Key Sizes for Personal Identity Verification</em> NIST<br></p>
																									   <p>[13] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 310</em> <br></p>
																									   <p>[14] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.6.1, Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.6.1, Requirement 6.5.3</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.6.1, Requirement 6.5.3</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.6.1, Requirement 6.5.8</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-12 Cryptographic Key Establishment and Management (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>time_and_state_code_correctness_erroneous_synchronization</key>
    <internalKey>Time and State/Code Correctness/Erroneous Synchronization</internalKey>
    <name>Code Correctness: Erroneous Synchronization</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  If a thread fails to unlock a mutex after signaling other threads, the other threads will remain locked waiting on the mutex.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  After a thread signals other threads waiting on a mutex, it must unlock the mutex by calling <code>pthread_mutex_unlock()</code> before another thread can begin running. If the signaling thread fails to unlock the mutex, the <code>pthread_cond_wait()</code> call in the second thread will not return and the thread will not execute.<br><br><b>Example 1:</b> The following code signals another thread waiting on a mutex by calling <code>pthread_cond_signal()</code>, but fails to unlock the mutex the other thread is waiting on.<br><br><pre><br>   ...<br>   pthread_mutex_lock(&amp;count_mutex);<br><br>   // Signal waiting thread<br>   pthread_cond_signal(&amp;count_threshold_cv);<br>   ...<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 373</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[9] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>time-and-state</tag>
  </rule>
  <rule>
    <key>time_and_state_insecure_temporary_file</key>
    <internalKey>Time and State/Insecure Temporary File</internalKey>
    <name>Insecure Temporary File</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Creating and using insecure temporary files can leave application and system data vulnerable to attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Applications require temporary files so frequently that many different mechanisms exist for creating them in the C Library and Windows(R) API. Most of these functions are vulnerable to various forms of attacks.<br><br><b>Example:</b> The following code uses a temporary file for storing intermediate data gathered from the network before it is processed.<br><br><pre><br>...<br>if (tmpnam_r(filename)){<br>	FILE* tmp = fopen(filename,"wb+");<br>	while((recv(sock,recvbuf,DATA_SIZE, 0) &gt; 0)&amp;&amp;(amt!=0))<br>		amt = fwrite(recvbuf,1,DATA_SIZE,tmp);<br>}<br>...<br></pre><br><br>This otherwise unremarkable code is vulnerable to a number of different attacks because it relies on an insecure method for creating temporary files. The vulnerabilities introduced by this function and others are described in the following sections. The most egregious security problems related to temporary file creation have occurred on Unix-based operating systems, but Windows applications have parallel risks. This section includes a discussion of temporary file creation on both Unix and Windows systems.<br><br>Methods and behaviors can vary between systems, but the fundamental risks introduced by each are reasonably constant. See the Recommendations section for information about safe core language functions and advice regarding a secure approach to creating temporary files.<br><br>The functions designed to aid in the creation of temporary files can be broken into two groups based on whether they simply provide a filename or actually open a new file.<br><br><b>Group 1 - "Unique" Filenames:</b><br><br>The first group of C Library and WinAPI functions designed to help with the process of creating temporary files do so by generating a unique file name for a new temporary file, which the program is then supposed to open. This group includes C Library functions like <code>tmpnam()</code>, <code>tempnam()</code>, <code>mktemp()</code> and their C++ equivalents prefaced with an <code>_</code> (underscore) as well as the <code>GetTempFileName()</code> function from the Windows API. This group of functions suffers from an underlying race condition on the filename chosen. Although the functions guarantee that the filename is unique at the time it is selected, there is no mechanism to prevent another process or an attacker from creating a file with the same name after it is selected but before the application attempts to open the file. Beyond the risk of a legitimate collision caused by another call to the same function, there is a high probability that an attacker will be able to create a malicious collision because the filenames generated by these functions are not sufficiently randomized to make them difficult to guess.<br><br>If a file with the selected name is created, then depending on how the file is opened the existing contents or access permissions of the file may remain intact. If the existing contents of the file are malicious in nature, an attacker may be able to inject dangerous data into the application when it reads data back from the temporary file. If an attacker pre-creates the file with relaxed access permissions, then data stored in the temporary file by the application may be accessed, modified or corrupted by an attacker. On Unix based systems an even more insidious attack is possible if the attacker pre-creates the file as a link to another important file. Then, if the application truncates or writes data to the file, it may unwittingly perform damaging operations for the attacker. This is an especially serious threat if the program operates with elevated permissions.<br><br>Finally, in the best case the file will be opened with a call to <code>open()</code> using the <code>O_CREAT</code> and <code>O_EXCL</code> flags or to <code>CreateFile()</code> using the <code>CREATE_NEW</code> attribute, which will fail if the file already exists and therefore prevent the types of attacks described above. However, if an attacker is able to accurately predict a sequence of temporary file names, then the application may be prevented from opening necessary temporary storage causing a denial of service (DoS) attack. This type of attack would not be difficult to mount given the small amount of randomness used in the selection of the filenames generated by these functions.<br><br><b>Group 2 - "Unique" Files:</b><br><br>The second group of C Library functions attempts to resolve some of the security problems related to temporary files by not only generating a unique file name, but also opening the file. This group includes C Library functions like <code>tmpfile()</code> and its C++ equivalents prefaced with an <code>_</code> (underscore), as well as the slightly better-behaved C Library function <code>mkstemp()</code>.<br><br>The <code>tmpfile()</code> style functions construct a unique filename and open it in the same way that <code>fopen()</code> would if passed the flags <code>"wb+"</code>, that is, as a binary file in read/write mode. If the file already exists, <code>tmpfile()</code> will truncate it to size zero, possibly in an attempt to assuage the security concerns mentioned earlier regarding the race condition that exists between the selection of a supposedly unique filename and the subsequent opening of the selected file. However, this behavior clearly does not solve the function's security problems. First, an attacker can pre-create the file with relaxed access-permissions that will likely be retained by the file opened by <code>tmpfile()</code>. Furthermore, on Unix based systems if the attacker pre-creates the file as a link to another important file, the application may use its possibly elevated permissions to truncate that file, thereby doing damage on behalf of the attacker. Finally, if <code>tmpfile()</code> does create a new file, the access permissions applied to that file will vary from one operating system to another, which can leave application data vulnerable even if an attacker is unable to predict the filename to be used in advance.<br><br>Finally, <code>mkstemp()</code> is a reasonably safe way to create temporary files. It will attempt to create and open a unique file based on a filename template provided by the user combined with a series of randomly generated characters. If it is unable to create such a file, it will fail and return <code>-1</code>. On modern systems the file is opened using mode <code>0600</code>, which means the file will be secure from tampering unless the user explicitly changes its access permissions. However, <code>mkstemp()</code> still suffers from the use of predictable file names and can leave an application vulnerable to denial of service attacks if an attacker causes <code>mkstemp()</code> to fail by predicting and pre-creating the filenames to be used.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em>.NET System.Security.Cryptography: Random Number Generation</em> Microsoft<br></p>
																									   <p>[2]  <em>BeeCrypt</em> <br></p>
																									   <p>[3]  <em>Crypt++</em> <br></p>
																									   <p>[4]  <em>CryptLib</em> <br></p>
																									   <p>[5]  <em>CryptoAPI: CryptGenRandom()</em> Microsoft<br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 377</em> <br></p>
																									   <p>[7]  <em>OpenSSL</em> <br></p>
																									   <p>[8]  <em>RtlGenRandom()</em> Microsoft<br></p>
																									   <p>[9] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-4 Information in Shared Resources (P1)</em> <br></p>
																									   <p>[10] B. Schneier <em>Yarrow: A secure pseudorandom number generator</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>time-and-state</tag>
  </rule>
  <rule>
    <key>time_and_state_race_condition_file_system_access</key>
    <internalKey>Time and State/Race Condition/File System Access</internalKey>
    <name>Race Condition: File System Access</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The window of time between when a file property is checked and when the file is used can be exploited to launch a privilege escalation attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  File access race conditions, known as time-of-check, time-of-use (TOCTOU) race conditions, occur when:<br><br>1. The program checks a property of a file, referencing the file by name.<br><br>2. The program later performs a filesystem operation using the same filename and assumes that the previously-checked property still holds.<br><br><br><b>Example 1:</b> The following code is from a program installed <code>setuid root</code>. The program performs certain file operations on behalf of non-privileged users, and uses access checks to ensure that it does not use its root privileges to perform operations that should otherwise be unavailable the current user. The program uses the <code>access()</code> system call to check if the person running the program has permission to access the specified file before it opens the file and performs the necessary operations.<br><br><pre><br>  if (!access(file,W_OK)) {<br>    f = fopen(file,"w+");<br>    operate(f);<br>    ...<br>  }<br>  else {<br>    fprintf(stderr,"Unable to open file %s.\n",file);<br>  }<br></pre><br><br>The call to <code>access()</code> behaves as expected, and returns <code>0</code> if the user running the program has the necessary permissions to write to the file, and -1 otherwise. However, because both <code>access()</code> and <code>fopen()</code> operate on filenames rather than on file handles, there is no guarantee that the <code>file</code> variable still refers to the same file on disk when it is passed to <code>fopen()</code> that it did when it was passed to <code>access()</code>. If an attacker replaces <code>file</code> after the call to <code>access()</code> with a symbolic link to a different file, the program will use its root privileges to operate on the file even if it is a file that the attacker would otherwise be unable to modify. By tricking the program into performing an operation that would otherwise be impermissible, the attacker has gained elevated privileges.<br><br>This type of vulnerability is not limited to programs with <code>root</code> privileges. If the application is capable of performing any operation that the attacker would not otherwise be allowed perform, then it is a possible target.<br><br>The window of vulnerability for such an attack is the period of time between when the property is tested and when the file is used. Even if the use immediately follows the check, modern operating systems offer no guarantee about the amount of code that will be executed before the process yields the CPU. Attackers have a variety of techniques for expanding the length of the window of opportunity in order to make exploits easier, but even with a small window, an exploit attempt can simply be repeated over and over until it is successful.<br><br><b>Example 2:</b> The following code creates a file and then changes the owner of the file.<br><br><pre><br>    fd = creat(FILE, 0644);  /* Create file */<br>    if (fd == -1)<br>        return;<br>    if (chown(FILE, UID, -1) &lt; 0) {  /* Change file owner */<br>      ...<br>    }<br></pre><br><br>The code assumes that the file operated upon by the call to <code>chown()</code> is the same as the file created by the call to <code>creat()</code>, but that is not necessarily the case.  Because <code>chown()</code> operates on a file name and not on a file handle, an attacker may be able to replace the file with a link to file the attacker does not own.  The call to <code>chown()</code> would then give the attacker ownership of the linked file.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[6] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 362, CWE ID 367</em> <br></p>
																									   <p>[8] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 362</em> <br></p>
																									   <p>[9] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 362</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>time-and-state</tag>
  </rule>
  <rule>
    <key>time_and_state_race_condition_signal_handling</key>
    <internalKey>Time and State/Race Condition/Signal Handling</internalKey>
    <name>Race Condition: Signal Handling</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Installing the same signal handler for multiple signals can lead to a race condition when different signals are caught in short succession.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Signal handling race conditions can occur whenever a function installed as a signal handler is non-reentrant, which means it maintains some internal state or calls another function that does so. Such race conditions are even more likely when the same function is installed to handle multiple signals.<br><br>Signal handling race conditions are more likely to occur when:<br><br>1.	The program installs a single signal handler for more than one signal.<br><br>2.	Two different signals for which the handler is installed arrive in short succession, causing a race condition in the signal handler.<br><br><b>Example:</b> The following code installs the same simple, non-reentrant signal handler for two different signals. If an attacker causes signals to be sent at the right moments, the signal handler will experience a double free vulnerability. Calling <code>free()</code> twice on the same value can lead to a buffer overflow. When a program calls <code>free()</code> twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to <code>malloc()</code> to return the same pointer. If <code>malloc()</code> returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.<br><br><pre><br>void sh(int dummy) {<br>  ...<br>  free(global2);<br>  free(global1);<br>  ...<br>}<br><br>int main(int argc,char* argv[]) {<br>  ...<br>  signal(SIGHUP,sh);<br>  signal(SIGTERM,sh);<br>  ...<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 362, CWE ID 364</em> <br></p>
																									   <p>[7] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 362</em> <br></p>
																									   <p>[8] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 362</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>time-and-state</tag>
  </rule>
</rules>
