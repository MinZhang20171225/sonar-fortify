
							<h2>ABSTRACT</h2>
							<p>
							  Explicitly deleting a managed pointer will cause the program to crash or otherwise misbehave.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Deleting a managed pointer will cause the program to crash or otherwise do the wrong thing when, later on, the pointer management code assumes that the pointer is still valid. The following example illustrates the error.<br><br><pre><br>  std::auto_ptr&lt;foo&gt; p(new foo);<br>  foo* rawFoo = p.get();<br>  delete rawFoo;<br></pre><br><br>The only exception to this rule comes when a managed pointer class supports a "detach" operation allowing the programmer to take control of memory management for the given pointer.  If the program detaches the pointer from the management class before calling <code>delete</code>, the management class knows not to use the pointer any further.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 730</em> <br></p>
																									   <p>[5] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[6] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection</em> <br></p>
																														