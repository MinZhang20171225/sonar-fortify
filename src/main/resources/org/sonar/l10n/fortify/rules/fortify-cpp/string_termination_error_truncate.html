
							<h2>ABSTRACT</h2>
							<p>
							  The program relies on proper string termination, but an intermediate function might have caused the source buffer to become unterminated. This could result in a buffer overflow.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  String termination errors caused by truncation occur when:<br><br>1. Data enters a program.<br><br>2. The data passes through a function that truncates it, removing the null terminator.<br><br>3. The data is passed to a function that requires its input to be null terminated.<br><b>Example 1:</b> The following code retrieves the value of a null-terminated environment variable and uses <code>strncpy()</code> to copy the data into <code>new</code> .  Later, the program incorrectly assumes <code>new</code> will always be null terminated when it is passed to <code>setenv()</code>. <br><br><pre><br>...<br>char *value = getenv("PWD");<br>...<br>char *new_value = strncpy(new, value, strlen(value));<br>setenv("PATH", new, 1);<br>...<br></pre><br><br>Because the call to <code>strncpy()</code> is bounded by the length of the string as computed by <code>strlen()</code>, which does not account for the null terminator, <code>new</code> will become unterminated and cause the call to <code>setenv()</code> to behave incorrectly. The function <code>setenv()</code> will continue copying from the memory following <code>new</code> until it encounters an arbitrary null character. If the function does not find a null terminator before reaching the maximum size of the program's environment, the behavior of the function and other environment functions is undefined. Even if an arbitrary null character is found, the <code>PATH</code> environment variable might be left pointing to invalid directories. Worse yet, if the attacker can control values in memory that follow <code>new</code>, then they might introduce malicious entries to <code>PATH</code>, thereby changing the meaning of commands executed subsequently. <br><br><b>Example 2:</b> In the following code, <code>fgets()</code> retrieves data from a stream and stores it in <code>buf</code>. The function guarantees that the data will not exceed the buffer size and that the result is null terminated. Later, <code>strncpy()</code> is used to copy a subset of the data to a new buffer, <code>data</code>. The length of the resulting value is then calculated using <code>strlen()</code>.<br><br><pre>...<br>char buf[MAXLEN];<br>fgets(buf, MAXLEN, stream);<br>...<br>strncpy(data, buf, data_size);<br>...<br>int length = strlen(data);<br>...<br></pre><br><br>The code in Example 2 will behave incorrectly if <code>data_size</code> is less than or equal to the length of data read from the stream because the null terminator will not be copied to <code>data</code>. In testing, vulnerabilities like this one might not be caught because the memory immediately following <code>data</code> will often be null, thereby causing <code>strlen()</code> to produce the correct answer accidentally. However, in practice, <code>strlen()</code> will continue traversing memory until it encounters an arbitrary null character on the stack, which can result in a value of <code>length</code> that is much larger than the size of <code>buf</code>. Subsequent operations on <code>data</code> that rely on <code>length</code>  might result in buffer overflow.<br><br>Traditionally, strings are represented as a region of memory containing data terminated with a null character. Older string-handling methods frequently rely on this null character to determine the length of the string. If a string is truncated by a function that does not guarantee null termination, the length function will read past the end of the buffer.<br>Malicious users could exploit this type of vulnerability by injecting data with an unexpectedly large size into the application. They may provide the malicious input either directly as input to the program or indirectly by modifying application resources, such as configuration files. In the event that an attacker causes the application to read beyond the bounds of a buffer, the attacker may be able to use a resulting buffer overflow to inject and execute arbitrary code on the system.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Buffer Overflow</em> <br></p>
																									   <p>[4] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 170</em> <br></p>
																									   <p>[5] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[6] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[7] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[8] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 665</em> <br></p>
																									   <p>[9] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 665</em> <br></p>
																									   <p>[10] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>
																														