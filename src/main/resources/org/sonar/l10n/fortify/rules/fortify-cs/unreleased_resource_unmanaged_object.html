
							<h2>ABSTRACT</h2>
							<p>
							  The program fails to dispose of a managed object that utilizes unmanaged system resources.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The program fails to properly dispose of a managed object that uses unmanaged system resources. <br>Failure to properly dispose of a managed object that uses unmanaged system resources has at least two common causes:<br><br>- Error conditions and other exceptional circumstances.<br>- Confusion over which part of the program is responsible for releasing the resource.<br><br>A small subset of managed .NET objects use unmanaged system resources.  .NET's Garbage Collector may not free the original managed objects in a predictable way.  As such, the application may run out of available memory as the Garbage Collector is unaware of the memory consumed by the unmanaged resources.  Most unmanaged resource leak issues result in general software reliability problems, but if an attacker can intentionally trigger an unmanaged resource leak, the attacker might be able to launch a denial of service attack by depleting the unmanaged resource pool.<br><br><b>Example 1:</b> The following method creates a managed Bitmap Object from an incoming stream <code>incomingStream</code>.  The Bitmap is manipulated and persisted to the outgoing stream <code>outgoingStream</code>.  The <code>Dispose()</code> method of <code>incomingBitmap</code> and <code>outgoingBitmap</code> is never explicitly called.<br><br>Normally, one can safely rely upon the Garbage Collector to do this at a safe time for managed objects that do not use unmanaged system resources.  The Garbage Collector calls <code>Bitmap.Dispose()</code> when it sees fit.  However, the <code>Bitmap</code> object utilizes scarce, unmanaged system resources.  The Garbage Collector may fail to call <code>Dispose()</code> before the unmanaged resource pool is depleted.  <br><br><pre><br>private void processBitmap(Stream incomingStream, Stream outgoingStream, int thumbnailSize)<br>{<br>	Bitmap incomingBitmap = (Bitmap)System.Drawing.Image.FromStream(incomingStream);<br>	<br>	bool validBitmap = validateBitmap(incomingBitmap);<br>	if (!validBitmap)<br>		throw new ValidationException(incomingBitmap);<br>	<br>	Bitmap outgoingBitmap = new Bitmap(incomingBitmap, new Size(thumbnailSize, thumbnailSize));<br>	outgoingBitmap.Save(outgoingStream, ImageFormat.Bmp);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 404</em> <br></p>
																									   <p>[5] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[6] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 404</em> <br></p>
																									   <p>[7] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection</em> <br></p>
																														