
							<h2>ABSTRACT</h2>
							<p>
							  Relying on proper string termination could result in a buffer overflow. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  String termination errors occur when:<br><br>1. Data enters a program via a function that does not null terminate its output. <br><br>2. The data is passed to a function that requires its input to be null terminated.<br><br><b>Example 1:</b> The following code reads from <code>cfgfile</code> and copies the input into <code>inputbuf</code> using <code>strcpy()</code>.  The code mistakenly assumes that <code>inputbuf</code> will always contain a null terminator. <br><br><pre><br>#define MAXLEN 1024<br>...<br>char *pathbuf[MAXLEN];<br>...<br>read(cfgfile,inputbuf,MAXLEN); //does not null terminate<br>strcpy(pathbuf,inputbuf); //requires null terminated input<br>...<br></pre><br><br>The code in Example 1 will behave correctly if the data read from <code>cfgfile</code> is null terminated on disk as expected. But if an attacker is able to modify this input so that it does not contain the expected null character, the call to <code>strcpy()</code> will continue copying from memory until it encounters an arbitrary null character. This will likely overflow the destination buffer and, if the attacker can control the contents of memory immediately following <code>inputbuf</code>, can leave the application susceptible to a buffer overflow attack.<br><br><b>Example 2:</b> In the following code, <code>readlink()</code> expands the name of a symbolic link stored in the buffer <code>path</code>  so that the buffer <code>buf</code> contains the absolute path of the file referenced by the symbolic link. The length of the resulting value is then calculated using <code>strlen()</code>. <br><br><pre><br>...<br>char buf[MAXPATH];<br>...<br>readlink(path, buf, MAXPATH);<br>int length = strlen(buf);<br>...<br></pre><br><br>The code in Example 2 will not behave correctly because the value read into <code>buf</code> by <code>readlink()</code> will not be null terminated. In testing, vulnerabilities like this one might not be caught because the unused contents of <code>buf</code> and the memory immediately following it may be null, thereby causing <code>strlen()</code> to appear as if it is behaving correctly. However, in the wild <code>strlen()</code> will continue traversing memory until it encounters an arbitrary null character on the stack, which results in a value of <code>length</code> that is much larger than the size of <code>buf</code> and may cause a buffer overflow in subsequent uses of this value. <br><br>Traditionally, strings are represented as a region of memory containing data terminated with a null character. Older string-handling methods frequently rely on this null character to determine the length of the string. If a buffer that does not contain a null terminator is passed to one of these functions, the function will read past the end of the buffer.<br><br>Malicious users typically exploit this type of vulnerability by injecting data with unexpected size or content into the application. They may provide the malicious input either directly as input to the program or indirectly by modifying application resources, such as configuration files. In the event that an attacker causes the application to read beyond the bounds of a buffer, the attacker may be able to use a resulting buffer overflow to inject and execute arbitrary code on the system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Buffer Overflow</em> <br></p>
																									   <p>[5] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 170</em> <br></p>
																									   <p>[6] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[7] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[9] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 665</em> <br></p>
																									   <p>[10] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 665</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation</em> <br></p>
																									   <p>[12] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>
																														