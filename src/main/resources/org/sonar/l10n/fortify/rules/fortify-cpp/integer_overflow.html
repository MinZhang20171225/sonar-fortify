
							<h2>ABSTRACT</h2>
							<p>
							  Not accounting for integer overflow can result in logic errors or buffer overflow.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Integer overflow errors occur when a program fails to account for the fact that an arithmetic operation can result in a quantity either greater than a data type's maximum value or less than its minimum value. These errors often cause problems in memory allocation functions, where user input intersects with an implicit conversion between signed and unsigned values. If an attacker can cause the program to under-allocate memory or interpret a signed value as an unsigned value in a memory operation, the program may be vulnerable to a buffer overflow.<br><br><b>Example 1:</b> The following code excerpt from OpenSSH 3.3 demonstrates a classic case of integer overflow:<br><br><pre><br>nresp = packet_get_int();<br>if (nresp &gt; 0) {<br> response = xmalloc(nresp*sizeof(char*));<br> for (i = 0; i &lt; nresp; i++)<br>  response[i] = packet_get_string(NULL);<br>}<br></pre><br><br>If <code>nresp</code> has the value <code>1073741824</code> and <code>sizeof(char*)</code> has its typical value of <code>4</code>, then the result of the operation <code>nresp*sizeof(char*)</code> overflows, and the argument to <code>xmalloc()</code> will be <code>0</code>. Most <code>malloc()</code> implementations will happily allocate a 0-byte buffer, causing the subsequent loop iterations to overflow the heap buffer <code>response</code>.<br><br><b>Example 2:</b> This example processes user input comprised of a series of variable-length structures. The first 2 bytes of input dictate the size of the structure to be processed.<br><br><pre><br> char* processNext(char* strm) {<br> char buf[512];<br> short len = *(short*) strm;<br> strm += sizeof(len);<br> if (len &lt;= 512) {<br>  memcpy(buf, strm, len);<br>  process(buf);<br>  return strm + len;<br> } else {<br>  return -1;<br> }<br>}<br></pre><br><br>The programmer has set an upper bound on the structure size: if it is larger than <code>512</code>, the input will not be processed. The problem is that <code>len</code> is a signed integer, so the check against the maximum structure length is done with signed integers, but <code>len</code> is converted to an unsigned integer for the call to <code>memcpy()</code>. If <code>len</code> is negative, then it will appear that the structure has an appropriate size (the <code>if</code> branch will be taken), but the amount of memory copied by <code>memcpy()</code> will be quite large, and the attacker will be able to overflow the stack with data in <code>strm</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3550 CAT I</em> <br></p>
																									   <p>[3] blexim <em>Basic Integer Overflows</em> Phrack<br></p>
																									   <p>[4] D. Plakosh <em>Coding Flaws That Lead to Security Failures</em> <br></p>
																									   <p>[5] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 190</em> <br></p>
																									   <p>[6] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[7] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1, Requirement 6.5.5</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[9] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 190</em> <br></p>
																									   <p>[10] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 682</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																														